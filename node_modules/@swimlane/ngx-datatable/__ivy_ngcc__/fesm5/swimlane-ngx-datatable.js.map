{"version":3,"sources":["/Users/syafiqbasri/Development/Project/SIC010/web/node_modules/@swimlane/ngx-datatable/fesm5/swimlane-ngx-datatable.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;;kCAuBkC,AAE3B;;;;;;;;;kCACiB;;;;;;;;;;;;;MAalB;;;;;gDAGmB;;;;;;;;;;;;;;;;;;;;;MAqBnB;;;;;gDAGuB;;;;;;;;;;SAUpB;;;;;;4EAGgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yDA+DgB;;;;;;;;;;;;;oBAG7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDA8G4B;;;;;;;;;;;;;;;;;;;;oBAG7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DAwFgC;;;;;;;;;;;;;;;;;;;;;;;;;;oBAQ/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qCAyJS,AAE9B;;;;;;;;;;;;;;;;;;;;;;oBACoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0DA4H+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAG/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDAoF2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAU5B;;;;;;;;;;SAUjB;;;;;;;;4EAKqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kEA4DoB;;;;;;;;;;;;;;;;;;;;;oBAG5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA8Y7B;;;;;;4EAG8B;;;;;;;;;;SAU9B;;;;;;4EAG4B;;;;;;;;;;SAU5B;;;;;;4EAG6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+EA4HyC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAG9C;;;;;;;;;;SAUxB;;;;;;;;4EAKmC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEA6DoB;;;;;;;;;;;;;;;;;;;;;oBAG5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qEAwCiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAGpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6DAiiC4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAU9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEAgTiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAU/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qCA+/CI,AAW9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAGoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sEAqP2C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DA6DsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAU1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DA0H2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAU5B;;;;;;KAM3B;;;;;;;;;;;;;;;;gDAOwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4CAgQe,AAMrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAC2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sEAqGoC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAUjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEA0a2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAO7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEA0L6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAO5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qEAqEiC;;;;;;;;;;;;;;;;;;;;;;;;;;oBAShC;;;;;;;;;;;;;;;;;;6BAkBR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAkDF","file":"swimlane-ngx-datatable.js","sourcesContent":["import { __decorate, __param, __values, __spread, __assign } from 'tslib';\nimport { Inject, Injectable, TemplateRef, Directive, EventEmitter, ElementRef, NgZone, HostBinding, Output, Input, Renderer2, HostListener, KeyValueDiffers, ContentChildren, Component, ChangeDetectionStrategy, ContentChild, ChangeDetectorRef, ViewChild, SkipSelf, Optional, ViewEncapsulation, ViewContainerRef, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, fromEvent, BehaviorSubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Gets the width of the scrollbar.  Nesc for windows\n * http://stackoverflow.com/a/13382873/888165\n */\nvar ScrollbarHelper = /** @class */ (function () {\n    function ScrollbarHelper(document) {\n        this.document = document;\n        this.width = this.getWidth();\n    }\n    ScrollbarHelper.prototype.getWidth = function () {\n        var outer = this.document.createElement('div');\n        outer.style.visibility = 'hidden';\n        outer.style.width = '100px';\n        outer.style.msOverflowStyle = 'scrollbar';\n        this.document.body.appendChild(outer);\n        var widthNoScroll = outer.offsetWidth;\n        outer.style.overflow = 'scroll';\n        var inner = this.document.createElement('div');\n        inner.style.width = '100%';\n        outer.appendChild(inner);\n        var widthWithScroll = inner.offsetWidth;\n        outer.parentNode.removeChild(outer);\n        return widthNoScroll - widthWithScroll;\n    };\n    ScrollbarHelper.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    ScrollbarHelper = __decorate([\n        Injectable(),\n        __param(0, Inject(DOCUMENT))\n    ], ScrollbarHelper);\n    return ScrollbarHelper;\n}());\n\n/**\n * Gets the width of the scrollbar.  Nesc for windows\n * http://stackoverflow.com/a/13382873/888165\n */\nvar DimensionsHelper = /** @class */ (function () {\n    function DimensionsHelper() {\n    }\n    DimensionsHelper.prototype.getDimensions = function (element) {\n        return element.getBoundingClientRect();\n    };\n    DimensionsHelper = __decorate([\n        Injectable()\n    ], DimensionsHelper);\n    return DimensionsHelper;\n}());\n\n/**\n * service to make DatatableComponent aware of changes to\n * input bindings of DataTableColumnDirective\n */\nvar ColumnChangesService = /** @class */ (function () {\n    function ColumnChangesService() {\n        this.columnInputChanges = new Subject();\n    }\n    Object.defineProperty(ColumnChangesService.prototype, \"columnInputChanges$\", {\n        get: function () {\n            return this.columnInputChanges.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ColumnChangesService.prototype.onInputChange = function () {\n        this.columnInputChanges.next();\n    };\n    ColumnChangesService = __decorate([\n        Injectable()\n    ], ColumnChangesService);\n    return ColumnChangesService;\n}());\n\nvar DataTableFooterTemplateDirective = /** @class */ (function () {\n    function DataTableFooterTemplateDirective(template) {\n        this.template = template;\n    }\n    DataTableFooterTemplateDirective.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    DataTableFooterTemplateDirective = __decorate([\n        Directive({ selector: '[ngx-datatable-footer-template]' })\n    ], DataTableFooterTemplateDirective);\n    return DataTableFooterTemplateDirective;\n}());\n\n/**\n * Visibility Observer Directive\n *\n * Usage:\n *\n * \t\t<div\n * \t\t\tvisibilityObserver\n * \t\t\t(visible)=\"onVisible($event)\">\n * \t\t</div>\n *\n */\nvar VisibilityDirective = /** @class */ (function () {\n    function VisibilityDirective(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.isVisible = false;\n        this.visible = new EventEmitter();\n    }\n    VisibilityDirective.prototype.ngOnInit = function () {\n        this.runCheck();\n    };\n    VisibilityDirective.prototype.ngOnDestroy = function () {\n        clearTimeout(this.timeout);\n    };\n    VisibilityDirective.prototype.onVisibilityChange = function () {\n        var _this = this;\n        // trigger zone recalc for columns\n        this.zone.run(function () {\n            _this.isVisible = true;\n            _this.visible.emit(true);\n        });\n    };\n    VisibilityDirective.prototype.runCheck = function () {\n        var _this = this;\n        var check = function () {\n            // https://davidwalsh.name/offsetheight-visibility\n            var _a = _this.element.nativeElement, offsetHeight = _a.offsetHeight, offsetWidth = _a.offsetWidth;\n            if (offsetHeight && offsetWidth) {\n                clearTimeout(_this.timeout);\n                _this.onVisibilityChange();\n            }\n            else {\n                clearTimeout(_this.timeout);\n                _this.zone.runOutsideAngular(function () {\n                    _this.timeout = setTimeout(function () { return check(); }, 50);\n                });\n            }\n        };\n        this.timeout = setTimeout(function () { return check(); });\n    };\n    VisibilityDirective.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: NgZone }\n    ]; };\n    __decorate([\n        HostBinding('class.visible')\n    ], VisibilityDirective.prototype, \"isVisible\", void 0);\n    __decorate([\n        Output()\n    ], VisibilityDirective.prototype, \"visible\", void 0);\n    VisibilityDirective = __decorate([\n        Directive({ selector: '[visibilityObserver]' })\n    ], VisibilityDirective);\n    return VisibilityDirective;\n}());\n\n/**\n * Draggable Directive for Angular2\n *\n * Inspiration:\n *   https://github.com/AngularClass/angular2-examples/blob/master/rx-draggable/directives/draggable.ts\n *   http://stackoverflow.com/questions/35662530/how-to-implement-drag-and-drop-in-angular2\n *\n */\nvar DraggableDirective = /** @class */ (function () {\n    function DraggableDirective(element) {\n        this.dragX = true;\n        this.dragY = true;\n        this.dragStart = new EventEmitter();\n        this.dragging = new EventEmitter();\n        this.dragEnd = new EventEmitter();\n        this.isDragging = false;\n        this.element = element.nativeElement;\n    }\n    DraggableDirective.prototype.ngOnChanges = function (changes) {\n        if (changes['dragEventTarget'] && changes['dragEventTarget'].currentValue && this.dragModel.dragging) {\n            this.onMousedown(changes['dragEventTarget'].currentValue);\n        }\n    };\n    DraggableDirective.prototype.ngOnDestroy = function () {\n        this._destroySubscription();\n    };\n    DraggableDirective.prototype.onMouseup = function (event) {\n        if (!this.isDragging)\n            return;\n        this.isDragging = false;\n        this.element.classList.remove('dragging');\n        if (this.subscription) {\n            this._destroySubscription();\n            this.dragEnd.emit({\n                event: event,\n                element: this.element,\n                model: this.dragModel\n            });\n        }\n    };\n    DraggableDirective.prototype.onMousedown = function (event) {\n        var _this = this;\n        // we only want to drag the inner header text\n        var isDragElm = event.target.classList.contains('draggable');\n        if (isDragElm && (this.dragX || this.dragY)) {\n            event.preventDefault();\n            this.isDragging = true;\n            var mouseDownPos_1 = { x: event.clientX, y: event.clientY };\n            var mouseup = fromEvent(document, 'mouseup');\n            this.subscription = mouseup.subscribe(function (ev) { return _this.onMouseup(ev); });\n            var mouseMoveSub = fromEvent(document, 'mousemove')\n                .pipe(takeUntil(mouseup))\n                .subscribe(function (ev) { return _this.move(ev, mouseDownPos_1); });\n            this.subscription.add(mouseMoveSub);\n            this.dragStart.emit({\n                event: event,\n                element: this.element,\n                model: this.dragModel\n            });\n        }\n    };\n    DraggableDirective.prototype.move = function (event, mouseDownPos) {\n        if (!this.isDragging)\n            return;\n        var x = event.clientX - mouseDownPos.x;\n        var y = event.clientY - mouseDownPos.y;\n        if (this.dragX)\n            this.element.style.left = x + \"px\";\n        if (this.dragY)\n            this.element.style.top = y + \"px\";\n        this.element.classList.add('dragging');\n        this.dragging.emit({\n            event: event,\n            element: this.element,\n            model: this.dragModel\n        });\n    };\n    DraggableDirective.prototype._destroySubscription = function () {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            this.subscription = undefined;\n        }\n    };\n    DraggableDirective.ctorParameters = function () { return [\n        { type: ElementRef }\n    ]; };\n    __decorate([\n        Input()\n    ], DraggableDirective.prototype, \"dragEventTarget\", void 0);\n    __decorate([\n        Input()\n    ], DraggableDirective.prototype, \"dragModel\", void 0);\n    __decorate([\n        Input()\n    ], DraggableDirective.prototype, \"dragX\", void 0);\n    __decorate([\n        Input()\n    ], DraggableDirective.prototype, \"dragY\", void 0);\n    __decorate([\n        Output()\n    ], DraggableDirective.prototype, \"dragStart\", void 0);\n    __decorate([\n        Output()\n    ], DraggableDirective.prototype, \"dragging\", void 0);\n    __decorate([\n        Output()\n    ], DraggableDirective.prototype, \"dragEnd\", void 0);\n    DraggableDirective = __decorate([\n        Directive({ selector: '[draggable]' })\n    ], DraggableDirective);\n    return DraggableDirective;\n}());\n\nvar ResizeableDirective = /** @class */ (function () {\n    function ResizeableDirective(element, renderer) {\n        this.renderer = renderer;\n        this.resizeEnabled = true;\n        this.resize = new EventEmitter();\n        this.resizing = false;\n        this.element = element.nativeElement;\n    }\n    ResizeableDirective.prototype.ngAfterViewInit = function () {\n        var renderer2 = this.renderer;\n        this.resizeHandle = renderer2.createElement('span');\n        if (this.resizeEnabled) {\n            renderer2.addClass(this.resizeHandle, 'resize-handle');\n        }\n        else {\n            renderer2.addClass(this.resizeHandle, 'resize-handle--not-resizable');\n        }\n        renderer2.appendChild(this.element, this.resizeHandle);\n    };\n    ResizeableDirective.prototype.ngOnDestroy = function () {\n        this._destroySubscription();\n        if (this.renderer.destroyNode) {\n            this.renderer.destroyNode(this.resizeHandle);\n        }\n        else if (this.resizeHandle) {\n            this.renderer.removeChild(this.renderer.parentNode(this.resizeHandle), this.resizeHandle);\n        }\n    };\n    ResizeableDirective.prototype.onMouseup = function () {\n        this.resizing = false;\n        if (this.subscription && !this.subscription.closed) {\n            this._destroySubscription();\n            this.resize.emit(this.element.clientWidth);\n        }\n    };\n    ResizeableDirective.prototype.onMousedown = function (event) {\n        var _this = this;\n        var isHandle = event.target.classList.contains('resize-handle');\n        var initialWidth = this.element.clientWidth;\n        var mouseDownScreenX = event.screenX;\n        if (isHandle) {\n            event.stopPropagation();\n            this.resizing = true;\n            var mouseup = fromEvent(document, 'mouseup');\n            this.subscription = mouseup.subscribe(function (ev) { return _this.onMouseup(); });\n            var mouseMoveSub = fromEvent(document, 'mousemove')\n                .pipe(takeUntil(mouseup))\n                .subscribe(function (e) { return _this.move(e, initialWidth, mouseDownScreenX); });\n            this.subscription.add(mouseMoveSub);\n        }\n    };\n    ResizeableDirective.prototype.move = function (event, initialWidth, mouseDownScreenX) {\n        var movementX = event.screenX - mouseDownScreenX;\n        var newWidth = initialWidth + movementX;\n        var overMinWidth = !this.minWidth || newWidth >= this.minWidth;\n        var underMaxWidth = !this.maxWidth || newWidth <= this.maxWidth;\n        if (overMinWidth && underMaxWidth) {\n            this.element.style.width = newWidth + \"px\";\n        }\n    };\n    ResizeableDirective.prototype._destroySubscription = function () {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            this.subscription = undefined;\n        }\n    };\n    ResizeableDirective.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: Renderer2 }\n    ]; };\n    __decorate([\n        Input()\n    ], ResizeableDirective.prototype, \"resizeEnabled\", void 0);\n    __decorate([\n        Input()\n    ], ResizeableDirective.prototype, \"minWidth\", void 0);\n    __decorate([\n        Input()\n    ], ResizeableDirective.prototype, \"maxWidth\", void 0);\n    __decorate([\n        Output()\n    ], ResizeableDirective.prototype, \"resize\", void 0);\n    __decorate([\n        HostListener('mousedown', ['$event'])\n    ], ResizeableDirective.prototype, \"onMousedown\", null);\n    ResizeableDirective = __decorate([\n        Directive({\n            selector: '[resizeable]',\n            host: {\n                '[class.resizeable]': 'resizeEnabled'\n            }\n        })\n    ], ResizeableDirective);\n    return ResizeableDirective;\n}());\n\nvar OrderableDirective = /** @class */ (function () {\n    function OrderableDirective(differs, document) {\n        this.document = document;\n        this.reorder = new EventEmitter();\n        this.targetChanged = new EventEmitter();\n        this.differ = differs.find({}).create();\n    }\n    OrderableDirective.prototype.ngAfterContentInit = function () {\n        // HACK: Investigate Better Way\n        this.updateSubscriptions();\n        this.draggables.changes.subscribe(this.updateSubscriptions.bind(this));\n    };\n    OrderableDirective.prototype.ngOnDestroy = function () {\n        this.draggables.forEach(function (d) {\n            d.dragStart.unsubscribe();\n            d.dragging.unsubscribe();\n            d.dragEnd.unsubscribe();\n        });\n    };\n    OrderableDirective.prototype.updateSubscriptions = function () {\n        var _this = this;\n        var diffs = this.differ.diff(this.createMapDiffs());\n        if (diffs) {\n            var subscribe = function (_a) {\n                var currentValue = _a.currentValue, previousValue = _a.previousValue;\n                unsubscribe_1({ previousValue: previousValue });\n                if (currentValue) {\n                    currentValue.dragStart.subscribe(_this.onDragStart.bind(_this));\n                    currentValue.dragging.subscribe(_this.onDragging.bind(_this));\n                    currentValue.dragEnd.subscribe(_this.onDragEnd.bind(_this));\n                }\n            };\n            var unsubscribe_1 = function (_a) {\n                var previousValue = _a.previousValue;\n                if (previousValue) {\n                    previousValue.dragStart.unsubscribe();\n                    previousValue.dragging.unsubscribe();\n                    previousValue.dragEnd.unsubscribe();\n                }\n            };\n            diffs.forEachAddedItem(subscribe);\n            // diffs.forEachChangedItem(subscribe.bind(this));\n            diffs.forEachRemovedItem(unsubscribe_1);\n        }\n    };\n    OrderableDirective.prototype.onDragStart = function () {\n        var e_1, _a;\n        this.positions = {};\n        var i = 0;\n        try {\n            for (var _b = __values(this.draggables.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var dragger = _c.value;\n                var elm = dragger.element;\n                var left = parseInt(elm.offsetLeft.toString(), 0);\n                this.positions[dragger.dragModel.prop] = {\n                    left: left,\n                    right: left + parseInt(elm.offsetWidth.toString(), 0),\n                    index: i++,\n                    element: elm\n                };\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    OrderableDirective.prototype.onDragging = function (_a) {\n        var element = _a.element, model = _a.model, event = _a.event;\n        var prevPos = this.positions[model.prop];\n        var target = this.isTarget(model, event);\n        if (target) {\n            if (this.lastDraggingIndex !== target.i) {\n                this.targetChanged.emit({\n                    prevIndex: this.lastDraggingIndex,\n                    newIndex: target.i,\n                    initialIndex: prevPos.index\n                });\n                this.lastDraggingIndex = target.i;\n            }\n        }\n        else if (this.lastDraggingIndex !== prevPos.index) {\n            this.targetChanged.emit({\n                prevIndex: this.lastDraggingIndex,\n                initialIndex: prevPos.index\n            });\n            this.lastDraggingIndex = prevPos.index;\n        }\n    };\n    OrderableDirective.prototype.onDragEnd = function (_a) {\n        var element = _a.element, model = _a.model, event = _a.event;\n        var prevPos = this.positions[model.prop];\n        var target = this.isTarget(model, event);\n        if (target) {\n            this.reorder.emit({\n                prevIndex: prevPos.index,\n                newIndex: target.i,\n                model: model\n            });\n        }\n        this.lastDraggingIndex = undefined;\n        element.style.left = 'auto';\n    };\n    OrderableDirective.prototype.isTarget = function (model, event) {\n        var i = 0;\n        var x = event.x || event.clientX;\n        var y = event.y || event.clientY;\n        var targets = this.document.elementsFromPoint(x, y);\n        var _loop_1 = function (prop) {\n            // current column position which throws event.\n            var pos = this_1.positions[prop];\n            // since we drag the inner span, we need to find it in the elements at the cursor\n            if (model.prop !== prop && targets.find(function (el) { return el === pos.element; })) {\n                return { value: {\n                        pos: pos,\n                        i: i\n                    } };\n            }\n            i++;\n        };\n        var this_1 = this;\n        for (var prop in this.positions) {\n            var state_1 = _loop_1(prop);\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n        }\n    };\n    OrderableDirective.prototype.createMapDiffs = function () {\n        return this.draggables.toArray().reduce(function (acc, curr) {\n            acc[curr.dragModel.$$id] = curr;\n            return acc;\n        }, {});\n    };\n    OrderableDirective.ctorParameters = function () { return [\n        { type: KeyValueDiffers },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n    ]; };\n    __decorate([\n        Output()\n    ], OrderableDirective.prototype, \"reorder\", void 0);\n    __decorate([\n        Output()\n    ], OrderableDirective.prototype, \"targetChanged\", void 0);\n    __decorate([\n        ContentChildren(DraggableDirective, { descendants: true })\n    ], OrderableDirective.prototype, \"draggables\", void 0);\n    OrderableDirective = __decorate([\n        Directive({ selector: '[orderable]' }),\n        __param(1, Inject(DOCUMENT))\n    ], OrderableDirective);\n    return OrderableDirective;\n}());\n\nvar LongPressDirective = /** @class */ (function () {\n    function LongPressDirective() {\n        this.pressEnabled = true;\n        this.duration = 500;\n        this.longPressStart = new EventEmitter();\n        this.longPressing = new EventEmitter();\n        this.longPressEnd = new EventEmitter();\n        this.mouseX = 0;\n        this.mouseY = 0;\n    }\n    Object.defineProperty(LongPressDirective.prototype, \"press\", {\n        get: function () {\n            return this.pressing;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(LongPressDirective.prototype, \"isLongPress\", {\n        get: function () {\n            return this.isLongPressing;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    LongPressDirective.prototype.onMouseDown = function (event) {\n        var _this = this;\n        // don't do right/middle clicks\n        if (event.which !== 1 || !this.pressEnabled)\n            return;\n        // don't start drag if its on resize handle\n        var target = event.target;\n        if (target.classList.contains('resize-handle'))\n            return;\n        this.mouseX = event.clientX;\n        this.mouseY = event.clientY;\n        this.pressing = true;\n        this.isLongPressing = false;\n        var mouseup = fromEvent(document, 'mouseup');\n        this.subscription = mouseup.subscribe(function (ev) { return _this.onMouseup(); });\n        this.timeout = setTimeout(function () {\n            _this.isLongPressing = true;\n            _this.longPressStart.emit({\n                event: event,\n                model: _this.pressModel\n            });\n            _this.subscription.add(fromEvent(document, 'mousemove')\n                .pipe(takeUntil(mouseup))\n                .subscribe(function (mouseEvent) { return _this.onMouseMove(mouseEvent); }));\n            _this.loop(event);\n        }, this.duration);\n        this.loop(event);\n    };\n    LongPressDirective.prototype.onMouseMove = function (event) {\n        if (this.pressing && !this.isLongPressing) {\n            var xThres = Math.abs(event.clientX - this.mouseX) > 10;\n            var yThres = Math.abs(event.clientY - this.mouseY) > 10;\n            if (xThres || yThres) {\n                this.endPress();\n            }\n        }\n    };\n    LongPressDirective.prototype.loop = function (event) {\n        var _this = this;\n        if (this.isLongPressing) {\n            this.timeout = setTimeout(function () {\n                _this.longPressing.emit({\n                    event: event,\n                    model: _this.pressModel\n                });\n                _this.loop(event);\n            }, 50);\n        }\n    };\n    LongPressDirective.prototype.endPress = function () {\n        clearTimeout(this.timeout);\n        this.isLongPressing = false;\n        this.pressing = false;\n        this._destroySubscription();\n        this.longPressEnd.emit({\n            model: this.pressModel\n        });\n    };\n    LongPressDirective.prototype.onMouseup = function () {\n        this.endPress();\n    };\n    LongPressDirective.prototype.ngOnDestroy = function () {\n        this._destroySubscription();\n    };\n    LongPressDirective.prototype._destroySubscription = function () {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n            this.subscription = undefined;\n        }\n    };\n    __decorate([\n        Input()\n    ], LongPressDirective.prototype, \"pressEnabled\", void 0);\n    __decorate([\n        Input()\n    ], LongPressDirective.prototype, \"pressModel\", void 0);\n    __decorate([\n        Input()\n    ], LongPressDirective.prototype, \"duration\", void 0);\n    __decorate([\n        Output()\n    ], LongPressDirective.prototype, \"longPressStart\", void 0);\n    __decorate([\n        Output()\n    ], LongPressDirective.prototype, \"longPressing\", void 0);\n    __decorate([\n        Output()\n    ], LongPressDirective.prototype, \"longPressEnd\", void 0);\n    __decorate([\n        HostBinding('class.press')\n    ], LongPressDirective.prototype, \"press\", null);\n    __decorate([\n        HostBinding('class.longpress')\n    ], LongPressDirective.prototype, \"isLongPress\", null);\n    __decorate([\n        HostListener('mousedown', ['$event'])\n    ], LongPressDirective.prototype, \"onMouseDown\", null);\n    LongPressDirective = __decorate([\n        Directive({ selector: '[long-press]' })\n    ], LongPressDirective);\n    return LongPressDirective;\n}());\n\nvar ScrollerComponent = /** @class */ (function () {\n    function ScrollerComponent(ngZone, element, renderer) {\n        this.ngZone = ngZone;\n        this.renderer = renderer;\n        this.scrollbarV = false;\n        this.scrollbarH = false;\n        this.scroll = new EventEmitter();\n        this.scrollYPos = 0;\n        this.scrollXPos = 0;\n        this.prevScrollYPos = 0;\n        this.prevScrollXPos = 0;\n        this._scrollEventListener = null;\n        this.element = element.nativeElement;\n    }\n    ScrollerComponent.prototype.ngOnInit = function () {\n        // manual bind so we don't always listen\n        if (this.scrollbarV || this.scrollbarH) {\n            var renderer = this.renderer;\n            this.parentElement = renderer.parentNode(renderer.parentNode(this.element));\n            this._scrollEventListener = this.onScrolled.bind(this);\n            this.parentElement.addEventListener('scroll', this._scrollEventListener);\n        }\n    };\n    ScrollerComponent.prototype.ngOnDestroy = function () {\n        if (this._scrollEventListener) {\n            this.parentElement.removeEventListener('scroll', this._scrollEventListener);\n            this._scrollEventListener = null;\n        }\n    };\n    ScrollerComponent.prototype.setOffset = function (offsetY) {\n        if (this.parentElement) {\n            this.parentElement.scrollTop = offsetY;\n        }\n    };\n    ScrollerComponent.prototype.onScrolled = function (event) {\n        var _this = this;\n        var dom = event.currentTarget;\n        requestAnimationFrame(function () {\n            _this.scrollYPos = dom.scrollTop;\n            _this.scrollXPos = dom.scrollLeft;\n            _this.updateOffset();\n        });\n    };\n    ScrollerComponent.prototype.updateOffset = function () {\n        var direction;\n        if (this.scrollYPos < this.prevScrollYPos) {\n            direction = 'down';\n        }\n        else if (this.scrollYPos > this.prevScrollYPos) {\n            direction = 'up';\n        }\n        this.scroll.emit({\n            direction: direction,\n            scrollYPos: this.scrollYPos,\n            scrollXPos: this.scrollXPos\n        });\n        this.prevScrollYPos = this.scrollYPos;\n        this.prevScrollXPos = this.scrollXPos;\n    };\n    ScrollerComponent.ctorParameters = function () { return [\n        { type: NgZone },\n        { type: ElementRef },\n        { type: Renderer2 }\n    ]; };\n    __decorate([\n        Input()\n    ], ScrollerComponent.prototype, \"scrollbarV\", void 0);\n    __decorate([\n        Input()\n    ], ScrollerComponent.prototype, \"scrollbarH\", void 0);\n    __decorate([\n        HostBinding('style.height.px'),\n        Input()\n    ], ScrollerComponent.prototype, \"scrollHeight\", void 0);\n    __decorate([\n        HostBinding('style.width.px'),\n        Input()\n    ], ScrollerComponent.prototype, \"scrollWidth\", void 0);\n    __decorate([\n        Output()\n    ], ScrollerComponent.prototype, \"scroll\", void 0);\n    ScrollerComponent = __decorate([\n        Component({\n            selector: 'datatable-scroller',\n            template: \" <ng-content></ng-content> \",\n            host: {\n                class: 'datatable-scroll'\n            },\n            changeDetection: ChangeDetectionStrategy.OnPush\n        })\n    ], ScrollerComponent);\n    return ScrollerComponent;\n}());\n\nvar DatatableGroupHeaderTemplateDirective = /** @class */ (function () {\n    function DatatableGroupHeaderTemplateDirective(template) {\n        this.template = template;\n    }\n    DatatableGroupHeaderTemplateDirective.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    DatatableGroupHeaderTemplateDirective = __decorate([\n        Directive({\n            selector: '[ngx-datatable-group-header-template]'\n        })\n    ], DatatableGroupHeaderTemplateDirective);\n    return DatatableGroupHeaderTemplateDirective;\n}());\n\nvar DatatableGroupHeaderDirective = /** @class */ (function () {\n    function DatatableGroupHeaderDirective() {\n        /**\n         * Row height is required when virtual scroll is enabled.\n         */\n        this.rowHeight = 0;\n        /**\n         * Track toggling of group visibility\n         */\n        this.toggle = new EventEmitter();\n    }\n    Object.defineProperty(DatatableGroupHeaderDirective.prototype, \"template\", {\n        get: function () {\n            return this._templateInput || this._templateQuery;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Toggle the expansion of a group\n     */\n    DatatableGroupHeaderDirective.prototype.toggleExpandGroup = function (group) {\n        this.toggle.emit({\n            type: 'group',\n            value: group\n        });\n    };\n    /**\n     * Expand all groups\n     */\n    DatatableGroupHeaderDirective.prototype.expandAllGroups = function () {\n        this.toggle.emit({\n            type: 'all',\n            value: true\n        });\n    };\n    /**\n     * Collapse all groups\n     */\n    DatatableGroupHeaderDirective.prototype.collapseAllGroups = function () {\n        this.toggle.emit({\n            type: 'all',\n            value: false\n        });\n    };\n    __decorate([\n        Input()\n    ], DatatableGroupHeaderDirective.prototype, \"rowHeight\", void 0);\n    __decorate([\n        Input('template')\n    ], DatatableGroupHeaderDirective.prototype, \"_templateInput\", void 0);\n    __decorate([\n        ContentChild(DatatableGroupHeaderTemplateDirective, { read: TemplateRef, static: true })\n    ], DatatableGroupHeaderDirective.prototype, \"_templateQuery\", void 0);\n    __decorate([\n        Output()\n    ], DatatableGroupHeaderDirective.prototype, \"toggle\", void 0);\n    DatatableGroupHeaderDirective = __decorate([\n        Directive({ selector: 'ngx-datatable-group-header' })\n    ], DatatableGroupHeaderDirective);\n    return DatatableGroupHeaderDirective;\n}());\n\n/**\n * Always returns the empty string ''\n */\nfunction emptyStringGetter() {\n    return '';\n}\n/**\n * Returns the appropriate getter function for this kind of prop.\n * If prop == null, returns the emptyStringGetter.\n */\nfunction getterForProp(prop) {\n    if (prop == null) {\n        return emptyStringGetter;\n    }\n    if (typeof prop === 'number') {\n        return numericIndexGetter;\n    }\n    else {\n        // deep or simple\n        if (prop.indexOf('.') !== -1) {\n            return deepValueGetter;\n        }\n        else {\n            return shallowValueGetter;\n        }\n    }\n}\n/**\n * Returns the value at this numeric index.\n * @param row array of values\n * @param index numeric index\n * @returns any or '' if invalid index\n */\nfunction numericIndexGetter(row, index) {\n    if (row == null) {\n        return '';\n    }\n    // mimic behavior of deepValueGetter\n    if (!row || index == null) {\n        return row;\n    }\n    var value = row[index];\n    if (value == null) {\n        return '';\n    }\n    return value;\n}\n/**\n * Returns the value of a field.\n * (more efficient than deepValueGetter)\n * @param obj object containing the field\n * @param fieldName field name string\n */\nfunction shallowValueGetter(obj, fieldName) {\n    if (obj == null) {\n        return '';\n    }\n    if (!obj || !fieldName) {\n        return obj;\n    }\n    var value = obj[fieldName];\n    if (value == null) {\n        return '';\n    }\n    return value;\n}\n/**\n * Returns a deep object given a string. zoo['animal.type']\n */\nfunction deepValueGetter(obj, path) {\n    if (obj == null) {\n        return '';\n    }\n    if (!obj || !path) {\n        return obj;\n    }\n    // check if path matches a root-level field\n    // { \"a.b.c\": 123 }\n    var current = obj[path];\n    if (current !== undefined) {\n        return current;\n    }\n    current = obj;\n    var split = path.split('.');\n    if (split.length) {\n        for (var i = 0; i < split.length; i++) {\n            current = current[split[i]];\n            // if found undefined, return empty string\n            if (current === undefined || current === null) {\n                return '';\n            }\n        }\n    }\n    return current;\n}\n\nfunction optionalGetterForProp(prop) {\n    return prop && (function (row) { return getterForProp(prop)(row, prop); });\n}\n/**\n * This functions rearrange items by their parents\n * Also sets the level value to each of the items\n *\n * Note: Expecting each item has a property called parentId\n * Note: This algorithm will fail if a list has two or more items with same ID\n * NOTE: This algorithm will fail if there is a deadlock of relationship\n *\n * For example,\n *\n * Input\n *\n * id -> parent\n * 1  -> 0\n * 2  -> 0\n * 3  -> 1\n * 4  -> 1\n * 5  -> 2\n * 7  -> 8\n * 6  -> 3\n *\n *\n * Output\n * id -> level\n * 1      -> 0\n * --3    -> 1\n * ----6  -> 2\n * --4    -> 1\n * 2      -> 0\n * --5    -> 1\n * 7     -> 8\n *\n *\n * @param rows\n *\n */\nfunction groupRowsByParents(rows, from, to) {\n    if (from && to) {\n        var nodeById = {};\n        var l = rows.length;\n        var node = null;\n        nodeById[0] = new TreeNode(); // that's the root node\n        var uniqIDs = rows.reduce(function (arr, item) {\n            var toValue = to(item);\n            if (arr.indexOf(toValue) === -1) {\n                arr.push(toValue);\n            }\n            return arr;\n        }, []);\n        for (var i = 0; i < l; i++) {\n            // make TreeNode objects for each item\n            nodeById[to(rows[i])] = new TreeNode(rows[i]);\n        }\n        for (var i = 0; i < l; i++) {\n            // link all TreeNode objects\n            node = nodeById[to(rows[i])];\n            var parent_1 = 0;\n            var fromValue = from(node.row);\n            if (!!fromValue && uniqIDs.indexOf(fromValue) > -1) {\n                parent_1 = fromValue;\n            }\n            node.parent = nodeById[parent_1];\n            node.row['level'] = node.parent.row['level'] + 1;\n            node.parent.children.push(node);\n        }\n        var resolvedRows_1 = [];\n        nodeById[0].flatten(function () {\n            resolvedRows_1 = __spread(resolvedRows_1, [this.row]);\n        }, true);\n        return resolvedRows_1;\n    }\n    else {\n        return rows;\n    }\n}\nvar TreeNode = /** @class */ (function () {\n    function TreeNode(row) {\n        if (row === void 0) { row = null; }\n        if (!row) {\n            row = {\n                level: -1,\n                treeStatus: 'expanded'\n            };\n        }\n        this.row = row;\n        this.parent = null;\n        this.children = [];\n    }\n    TreeNode.prototype.flatten = function (f, recursive) {\n        if (this.row['treeStatus'] === 'expanded') {\n            for (var i = 0, l = this.children.length; i < l; i++) {\n                var child = this.children[i];\n                f.apply(child, Array.prototype.slice.call(arguments, 2));\n                if (recursive)\n                    child.flatten.apply(child, arguments);\n            }\n        }\n    };\n    return TreeNode;\n}());\n\n/**\n * Converts strings from something to camel case\n * http://stackoverflow.com/questions/10425287/convert-dash-separated-string-to-camelcase\n */\nfunction camelCase(str) {\n    // Replace special characters with a space\n    str = str.replace(/[^a-zA-Z0-9 ]/g, ' ');\n    // put a space before an uppercase letter\n    str = str.replace(/([a-z](?=[A-Z]))/g, '$1 ');\n    // Lower case first character and some other stuff\n    str = str\n        .replace(/([^a-zA-Z0-9 ])|^[0-9]+/g, '')\n        .trim()\n        .toLowerCase();\n    // uppercase characters preceded by a space or number\n    str = str.replace(/([ 0-9]+)([a-zA-Z])/g, function (a, b, c) {\n        return b.trim() + c.toUpperCase();\n    });\n    return str;\n}\n/**\n * Converts strings from camel case to words\n * http://stackoverflow.com/questions/7225407/convert-camelcasetext-to-camel-case-text\n */\nfunction deCamelCase(str) {\n    return str.replace(/([A-Z])/g, function (match) { return \" \" + match; }).replace(/^./, function (match) { return match.toUpperCase(); });\n}\n\n/**\n * Creates a unique object id.\n * http://stackoverflow.com/questions/6248666/how-to-generate-short-uid-like-ax4j9z-in-js\n */\nfunction id() {\n    return ('0000' + ((Math.random() * Math.pow(36, 4)) << 0).toString(36)).slice(-4);\n}\n\n/**\n * Sets the column defaults\n */\nfunction setColumnDefaults(columns) {\n    var e_1, _a;\n    if (!columns)\n        return;\n    // Only one column should hold the tree view\n    // Thus if multiple columns are provided with\n    // isTreeColumn as true we take only the first one\n    var treeColumnFound = false;\n    try {\n        for (var columns_1 = __values(columns), columns_1_1 = columns_1.next(); !columns_1_1.done; columns_1_1 = columns_1.next()) {\n            var column = columns_1_1.value;\n            if (!column.$$id) {\n                column.$$id = id();\n            }\n            // prop can be numeric; zero is valid not a missing prop\n            // translate name => prop\n            if (isNullOrUndefined(column.prop) && column.name) {\n                column.prop = camelCase(column.name);\n            }\n            if (!column.$$valueGetter) {\n                column.$$valueGetter = getterForProp(column.prop);\n            }\n            // format props if no name passed\n            if (!isNullOrUndefined(column.prop) && isNullOrUndefined(column.name)) {\n                column.name = deCamelCase(String(column.prop));\n            }\n            if (isNullOrUndefined(column.prop) && isNullOrUndefined(column.name)) {\n                column.name = ''; // Fixes IE and Edge displaying `null`\n            }\n            if (!column.hasOwnProperty('resizeable')) {\n                column.resizeable = true;\n            }\n            if (!column.hasOwnProperty('sortable')) {\n                column.sortable = true;\n            }\n            if (!column.hasOwnProperty('draggable')) {\n                column.draggable = true;\n            }\n            if (!column.hasOwnProperty('canAutoResize')) {\n                column.canAutoResize = true;\n            }\n            if (!column.hasOwnProperty('width')) {\n                column.width = 150;\n            }\n            if (!column.hasOwnProperty('isTreeColumn')) {\n                column.isTreeColumn = false;\n            }\n            else {\n                if (column.isTreeColumn && !treeColumnFound) {\n                    // If the first column with isTreeColumn is true found\n                    // we mark that treeCoulmn is found\n                    treeColumnFound = true;\n                }\n                else {\n                    // After that isTreeColumn property for any other column\n                    // will be set as false\n                    column.isTreeColumn = false;\n                }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (columns_1_1 && !columns_1_1.done && (_a = columns_1.return)) _a.call(columns_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * Translates templates definitions to objects\n */\nfunction translateTemplates(templates) {\n    var e_2, _a, e_3, _b;\n    var result = [];\n    try {\n        for (var templates_1 = __values(templates), templates_1_1 = templates_1.next(); !templates_1_1.done; templates_1_1 = templates_1.next()) {\n            var temp = templates_1_1.value;\n            var col = {};\n            var props = Object.getOwnPropertyNames(temp);\n            try {\n                for (var props_1 = (e_3 = void 0, __values(props)), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n                    var prop = props_1_1.value;\n                    col[prop] = temp[prop];\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (props_1_1 && !props_1_1.done && (_b = props_1.return)) _b.call(props_1);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n            if (temp.headerTemplate) {\n                col.headerTemplate = temp.headerTemplate;\n            }\n            if (temp.cellTemplate) {\n                col.cellTemplate = temp.cellTemplate;\n            }\n            if (temp.summaryFunc) {\n                col.summaryFunc = temp.summaryFunc;\n            }\n            if (temp.summaryTemplate) {\n                col.summaryTemplate = temp.summaryTemplate;\n            }\n            result.push(col);\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (templates_1_1 && !templates_1_1.done && (_a = templates_1.return)) _a.call(templates_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return result;\n}\n\nvar ColumnMode;\n(function (ColumnMode) {\n    ColumnMode[\"standard\"] = \"standard\";\n    ColumnMode[\"flex\"] = \"flex\";\n    ColumnMode[\"force\"] = \"force\";\n})(ColumnMode || (ColumnMode = {}));\n\nvar SelectionType;\n(function (SelectionType) {\n    SelectionType[\"single\"] = \"single\";\n    SelectionType[\"multi\"] = \"multi\";\n    SelectionType[\"multiClick\"] = \"multiClick\";\n    SelectionType[\"cell\"] = \"cell\";\n    SelectionType[\"checkbox\"] = \"checkbox\";\n})(SelectionType || (SelectionType = {}));\n\nvar SortType;\n(function (SortType) {\n    SortType[\"single\"] = \"single\";\n    SortType[\"multi\"] = \"multi\";\n})(SortType || (SortType = {}));\n\nvar ContextmenuType;\n(function (ContextmenuType) {\n    ContextmenuType[\"header\"] = \"header\";\n    ContextmenuType[\"body\"] = \"body\";\n})(ContextmenuType || (ContextmenuType = {}));\n\nvar DataTableColumnHeaderDirective = /** @class */ (function () {\n    function DataTableColumnHeaderDirective(template) {\n        this.template = template;\n    }\n    DataTableColumnHeaderDirective.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    DataTableColumnHeaderDirective = __decorate([\n        Directive({ selector: '[ngx-datatable-header-template]' })\n    ], DataTableColumnHeaderDirective);\n    return DataTableColumnHeaderDirective;\n}());\n\nvar DataTableColumnCellDirective = /** @class */ (function () {\n    function DataTableColumnCellDirective(template) {\n        this.template = template;\n    }\n    DataTableColumnCellDirective.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    DataTableColumnCellDirective = __decorate([\n        Directive({ selector: '[ngx-datatable-cell-template]' })\n    ], DataTableColumnCellDirective);\n    return DataTableColumnCellDirective;\n}());\n\nvar DataTableColumnCellTreeToggle = /** @class */ (function () {\n    function DataTableColumnCellTreeToggle(template) {\n        this.template = template;\n    }\n    DataTableColumnCellTreeToggle.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    DataTableColumnCellTreeToggle = __decorate([\n        Directive({ selector: '[ngx-datatable-tree-toggle]' })\n    ], DataTableColumnCellTreeToggle);\n    return DataTableColumnCellTreeToggle;\n}());\n\nvar DataTableColumnDirective = /** @class */ (function () {\n    function DataTableColumnDirective(columnChangesService) {\n        this.columnChangesService = columnChangesService;\n        this.isFirstChange = true;\n    }\n    Object.defineProperty(DataTableColumnDirective.prototype, \"cellTemplate\", {\n        get: function () {\n            return this._cellTemplateInput || this._cellTemplateQuery;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableColumnDirective.prototype, \"headerTemplate\", {\n        get: function () {\n            return this._headerTemplateInput || this._headerTemplateQuery;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableColumnDirective.prototype, \"treeToggleTemplate\", {\n        get: function () {\n            return this._treeToggleTemplateInput || this._treeToggleTemplateQuery;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTableColumnDirective.prototype.ngOnChanges = function () {\n        if (this.isFirstChange) {\n            this.isFirstChange = false;\n        }\n        else {\n            this.columnChangesService.onInputChange();\n        }\n    };\n    DataTableColumnDirective.ctorParameters = function () { return [\n        { type: ColumnChangesService }\n    ]; };\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"name\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"prop\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"frozenLeft\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"frozenRight\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"flexGrow\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"resizeable\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"comparator\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"pipe\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"sortable\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"draggable\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"canAutoResize\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"minWidth\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"width\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"maxWidth\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"checkboxable\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"headerCheckboxable\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"headerClass\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"cellClass\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"isTreeColumn\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"treeLevelIndent\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"summaryFunc\", void 0);\n    __decorate([\n        Input()\n    ], DataTableColumnDirective.prototype, \"summaryTemplate\", void 0);\n    __decorate([\n        Input('cellTemplate')\n    ], DataTableColumnDirective.prototype, \"_cellTemplateInput\", void 0);\n    __decorate([\n        ContentChild(DataTableColumnCellDirective, { read: TemplateRef, static: true })\n    ], DataTableColumnDirective.prototype, \"_cellTemplateQuery\", void 0);\n    __decorate([\n        Input('headerTemplate')\n    ], DataTableColumnDirective.prototype, \"_headerTemplateInput\", void 0);\n    __decorate([\n        ContentChild(DataTableColumnHeaderDirective, { read: TemplateRef, static: true })\n    ], DataTableColumnDirective.prototype, \"_headerTemplateQuery\", void 0);\n    __decorate([\n        Input('treeToggleTemplate')\n    ], DataTableColumnDirective.prototype, \"_treeToggleTemplateInput\", void 0);\n    __decorate([\n        ContentChild(DataTableColumnCellTreeToggle, { read: TemplateRef, static: true })\n    ], DataTableColumnDirective.prototype, \"_treeToggleTemplateQuery\", void 0);\n    DataTableColumnDirective = __decorate([\n        Directive({ selector: 'ngx-datatable-column' })\n    ], DataTableColumnDirective);\n    return DataTableColumnDirective;\n}());\n\nvar DatatableRowDetailTemplateDirective = /** @class */ (function () {\n    function DatatableRowDetailTemplateDirective(template) {\n        this.template = template;\n    }\n    DatatableRowDetailTemplateDirective.ctorParameters = function () { return [\n        { type: TemplateRef }\n    ]; };\n    DatatableRowDetailTemplateDirective = __decorate([\n        Directive({\n            selector: '[ngx-datatable-row-detail-template]'\n        })\n    ], DatatableRowDetailTemplateDirective);\n    return DatatableRowDetailTemplateDirective;\n}());\n\nvar DatatableRowDetailDirective = /** @class */ (function () {\n    function DatatableRowDetailDirective() {\n        /**\n         * The detail row height is required especially\n         * when virtual scroll is enabled.\n         */\n        this.rowHeight = 0;\n        /**\n         * Row detail row visbility was toggled.\n         */\n        this.toggle = new EventEmitter();\n    }\n    Object.defineProperty(DatatableRowDetailDirective.prototype, \"template\", {\n        get: function () {\n            return this._templateInput || this._templateQuery;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Toggle the expansion of the row\n     */\n    DatatableRowDetailDirective.prototype.toggleExpandRow = function (row) {\n        this.toggle.emit({\n            type: 'row',\n            value: row\n        });\n    };\n    /**\n     * API method to expand all the rows.\n     */\n    DatatableRowDetailDirective.prototype.expandAllRows = function () {\n        this.toggle.emit({\n            type: 'all',\n            value: true\n        });\n    };\n    /**\n     * API method to collapse all the rows.\n     */\n    DatatableRowDetailDirective.prototype.collapseAllRows = function () {\n        this.toggle.emit({\n            type: 'all',\n            value: false\n        });\n    };\n    __decorate([\n        Input()\n    ], DatatableRowDetailDirective.prototype, \"rowHeight\", void 0);\n    __decorate([\n        Input('template')\n    ], DatatableRowDetailDirective.prototype, \"_templateInput\", void 0);\n    __decorate([\n        ContentChild(DatatableRowDetailTemplateDirective, { read: TemplateRef, static: true })\n    ], DatatableRowDetailDirective.prototype, \"_templateQuery\", void 0);\n    __decorate([\n        Output()\n    ], DatatableRowDetailDirective.prototype, \"toggle\", void 0);\n    DatatableRowDetailDirective = __decorate([\n        Directive({ selector: 'ngx-datatable-row-detail' })\n    ], DatatableRowDetailDirective);\n    return DatatableRowDetailDirective;\n}());\n\nvar DatatableFooterDirective = /** @class */ (function () {\n    function DatatableFooterDirective() {\n    }\n    Object.defineProperty(DatatableFooterDirective.prototype, \"template\", {\n        get: function () {\n            return this._templateInput || this._templateQuery;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate([\n        Input()\n    ], DatatableFooterDirective.prototype, \"footerHeight\", void 0);\n    __decorate([\n        Input()\n    ], DatatableFooterDirective.prototype, \"totalMessage\", void 0);\n    __decorate([\n        Input()\n    ], DatatableFooterDirective.prototype, \"selectedMessage\", void 0);\n    __decorate([\n        Input()\n    ], DatatableFooterDirective.prototype, \"pagerLeftArrowIcon\", void 0);\n    __decorate([\n        Input()\n    ], DatatableFooterDirective.prototype, \"pagerRightArrowIcon\", void 0);\n    __decorate([\n        Input()\n    ], DatatableFooterDirective.prototype, \"pagerPreviousIcon\", void 0);\n    __decorate([\n        Input()\n    ], DatatableFooterDirective.prototype, \"pagerNextIcon\", void 0);\n    __decorate([\n        Input('template')\n    ], DatatableFooterDirective.prototype, \"_templateInput\", void 0);\n    __decorate([\n        ContentChild(DataTableFooterTemplateDirective, { read: TemplateRef })\n    ], DatatableFooterDirective.prototype, \"_templateQuery\", void 0);\n    DatatableFooterDirective = __decorate([\n        Directive({ selector: 'ngx-datatable-footer' })\n    ], DatatableFooterDirective);\n    return DatatableFooterDirective;\n}());\n\n/**\n * Returns the columns by pin.\n */\nfunction columnsByPin(cols) {\n    var e_1, _a;\n    var ret = {\n        left: [],\n        center: [],\n        right: []\n    };\n    if (cols) {\n        try {\n            for (var cols_1 = __values(cols), cols_1_1 = cols_1.next(); !cols_1_1.done; cols_1_1 = cols_1.next()) {\n                var col = cols_1_1.value;\n                if (col.frozenLeft) {\n                    ret.left.push(col);\n                }\n                else if (col.frozenRight) {\n                    ret.right.push(col);\n                }\n                else {\n                    ret.center.push(col);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (cols_1_1 && !cols_1_1.done && (_a = cols_1.return)) _a.call(cols_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    return ret;\n}\n/**\n * Returns the widths of all group sets of a column\n */\nfunction columnGroupWidths(groups, all) {\n    return {\n        left: columnTotalWidth(groups.left),\n        center: columnTotalWidth(groups.center),\n        right: columnTotalWidth(groups.right),\n        total: Math.floor(columnTotalWidth(all))\n    };\n}\n/**\n * Calculates the total width of all columns and their groups\n */\nfunction columnTotalWidth(columns, prop) {\n    var e_2, _a;\n    var totalWidth = 0;\n    if (columns) {\n        try {\n            for (var columns_1 = __values(columns), columns_1_1 = columns_1.next(); !columns_1_1.done; columns_1_1 = columns_1.next()) {\n                var c = columns_1_1.value;\n                var has = prop && c[prop];\n                var width = has ? c[prop] : c.width;\n                totalWidth = totalWidth + parseFloat(width);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (columns_1_1 && !columns_1_1.done && (_a = columns_1.return)) _a.call(columns_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    return totalWidth;\n}\n/**\n * Calculates the total width of all columns and their groups\n */\nfunction columnsTotalWidth(columns, prop) {\n    var e_3, _a;\n    var totalWidth = 0;\n    try {\n        for (var columns_2 = __values(columns), columns_2_1 = columns_2.next(); !columns_2_1.done; columns_2_1 = columns_2.next()) {\n            var column = columns_2_1.value;\n            var has = prop && column[prop];\n            totalWidth = totalWidth + (has ? column[prop] : column.width);\n        }\n    }\n    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n    finally {\n        try {\n            if (columns_2_1 && !columns_2_1.done && (_a = columns_2.return)) _a.call(columns_2);\n        }\n        finally { if (e_3) throw e_3.error; }\n    }\n    return totalWidth;\n}\nfunction columnsByPinArr(val) {\n    var colsByPinArr = [];\n    var colsByPin = columnsByPin(val);\n    colsByPinArr.push({ type: 'left', columns: colsByPin['left'] });\n    colsByPinArr.push({ type: 'center', columns: colsByPin['center'] });\n    colsByPinArr.push({ type: 'right', columns: colsByPin['right'] });\n    return colsByPinArr;\n}\n\n/**\n * This object contains the cache of the various row heights that are present inside\n * the data table.   Its based on Fenwick tree data structure that helps with\n * querying sums that have time complexity of log n.\n *\n * Fenwick Tree Credits: http://petr-mitrichev.blogspot.com/2013/05/fenwick-tree-range-updates.html\n * https://github.com/mikolalysenko/fenwick-tree\n *\n */\nvar RowHeightCache = /** @class */ (function () {\n    function RowHeightCache() {\n        /**\n         * Tree Array stores the cumulative information of the row heights to perform efficient\n         * range queries and updates.  Currently the tree is initialized to the base row\n         * height instead of the detail row height.\n         */\n        this.treeArray = [];\n    }\n    /**\n     * Clear the Tree array.\n     */\n    RowHeightCache.prototype.clearCache = function () {\n        this.treeArray = [];\n    };\n    /**\n     * Initialize the Fenwick tree with row Heights.\n     *\n     * @param rows The array of rows which contain the expanded status.\n     * @param rowHeight The row height.\n     * @param detailRowHeight The detail row height.\n     */\n    RowHeightCache.prototype.initCache = function (details) {\n        var rows = details.rows, rowHeight = details.rowHeight, detailRowHeight = details.detailRowHeight, externalVirtual = details.externalVirtual, rowCount = details.rowCount, rowIndexes = details.rowIndexes, rowExpansions = details.rowExpansions;\n        var isFn = typeof rowHeight === 'function';\n        var isDetailFn = typeof detailRowHeight === 'function';\n        if (!isFn && isNaN(rowHeight)) {\n            throw new Error(\"Row Height cache initialization failed. Please ensure that 'rowHeight' is a\\n        valid number or function value: (\" + rowHeight + \") when 'scrollbarV' is enabled.\");\n        }\n        // Add this additional guard in case detailRowHeight is set to 'auto' as it wont work.\n        if (!isDetailFn && isNaN(detailRowHeight)) {\n            throw new Error(\"Row Height cache initialization failed. Please ensure that 'detailRowHeight' is a\\n        valid number or function value: (\" + detailRowHeight + \") when 'scrollbarV' is enabled.\");\n        }\n        var n = externalVirtual ? rowCount : rows.length;\n        this.treeArray = new Array(n);\n        for (var i = 0; i < n; ++i) {\n            this.treeArray[i] = 0;\n        }\n        for (var i = 0; i < n; ++i) {\n            var row = rows[i];\n            var currentRowHeight = rowHeight;\n            if (isFn) {\n                currentRowHeight = rowHeight(row);\n            }\n            // Add the detail row height to the already expanded rows.\n            // This is useful for the table that goes through a filter or sort.\n            var expanded = rowExpansions.has(row);\n            if (row && expanded) {\n                if (isDetailFn) {\n                    var index = rowIndexes.get(row);\n                    currentRowHeight += detailRowHeight(row, index);\n                }\n                else {\n                    currentRowHeight += detailRowHeight;\n                }\n            }\n            this.update(i, currentRowHeight);\n        }\n    };\n    /**\n     * Given the ScrollY position i.e. sum, provide the rowIndex\n     * that is present in the current view port.  Below handles edge cases.\n     */\n    RowHeightCache.prototype.getRowIndex = function (scrollY) {\n        if (scrollY === 0)\n            return 0;\n        return this.calcRowIndex(scrollY);\n    };\n    /**\n     * When a row is expanded or rowHeight is changed, update the height.  This can\n     * be utilized in future when Angular Data table supports dynamic row heights.\n     */\n    RowHeightCache.prototype.update = function (atRowIndex, byRowHeight) {\n        if (!this.treeArray.length) {\n            throw new Error(\"Update at index \" + atRowIndex + \" with value \" + byRowHeight + \" failed:\\n        Row Height cache not initialized.\");\n        }\n        var n = this.treeArray.length;\n        atRowIndex |= 0;\n        while (atRowIndex < n) {\n            this.treeArray[atRowIndex] += byRowHeight;\n            atRowIndex |= atRowIndex + 1;\n        }\n    };\n    /**\n     * Range Sum query from 1 to the rowIndex\n     */\n    RowHeightCache.prototype.query = function (atIndex) {\n        if (!this.treeArray.length) {\n            throw new Error(\"query at index \" + atIndex + \" failed: Fenwick tree array not initialized.\");\n        }\n        var sum = 0;\n        atIndex |= 0;\n        while (atIndex >= 0) {\n            sum += this.treeArray[atIndex];\n            atIndex = (atIndex & (atIndex + 1)) - 1;\n        }\n        return sum;\n    };\n    /**\n     * Find the total height between 2 row indexes\n     */\n    RowHeightCache.prototype.queryBetween = function (atIndexA, atIndexB) {\n        return this.query(atIndexB) - this.query(atIndexA - 1);\n    };\n    /**\n     * Given the ScrollY position i.e. sum, provide the rowIndex\n     * that is present in the current view port.\n     */\n    RowHeightCache.prototype.calcRowIndex = function (sum) {\n        if (!this.treeArray.length)\n            return 0;\n        var pos = -1;\n        var dataLength = this.treeArray.length;\n        // Get the highest bit for the block size.\n        var highestBit = Math.pow(2, dataLength.toString(2).length - 1);\n        for (var blockSize = highestBit; blockSize !== 0; blockSize >>= 1) {\n            var nextPos = pos + blockSize;\n            if (nextPos < dataLength && sum >= this.treeArray[nextPos]) {\n                sum -= this.treeArray[nextPos];\n                pos = nextPos;\n            }\n        }\n        return pos + 1;\n    };\n    return RowHeightCache;\n}());\n\nvar cache = {};\nvar testStyle = typeof document !== 'undefined' ? document.createElement('div').style : undefined;\nvar ɵ0 = function () {\n    var styles = typeof window !== 'undefined' ? window.getComputedStyle(document.documentElement, '') : undefined;\n    var match = typeof styles !== 'undefined'\n        ? Array.prototype.slice\n            .call(styles)\n            .join('')\n            .match(/-(moz|webkit|ms)-/)\n        : null;\n    var pre = match !== null ? match[1] : undefined;\n    // tslint:disable-next-line: tsr-detect-non-literal-regexp\n    var dom = typeof pre !== 'undefined' ? 'WebKit|Moz|MS|O'.match(new RegExp('(' + pre + ')', 'i'))[1] : undefined;\n    return dom\n        ? {\n            dom: dom,\n            lowercase: pre,\n            css: \"-\" + pre + \"-\",\n            js: pre[0].toUpperCase() + pre.substr(1)\n        }\n        : undefined;\n};\n// Get Prefix\n// http://davidwalsh.name/vendor-prefix\nvar prefix = (ɵ0)();\nfunction getVendorPrefixedName(property) {\n    var name = camelCase(property);\n    if (!cache[name]) {\n        if (prefix !== undefined && testStyle[prefix.css + property] !== undefined) {\n            cache[name] = prefix.css + property;\n        }\n        else if (testStyle[property] !== undefined) {\n            cache[name] = property;\n        }\n    }\n    return cache[name];\n}\n\n// browser detection and prefixing tools\nvar transform = typeof window !== 'undefined' ? getVendorPrefixedName('transform') : undefined;\nvar backfaceVisibility = typeof window !== 'undefined' ? getVendorPrefixedName('backfaceVisibility') : undefined;\nvar hasCSSTransforms = typeof window !== 'undefined' ? !!getVendorPrefixedName('transform') : undefined;\nvar hasCSS3DTransforms = typeof window !== 'undefined' ? !!getVendorPrefixedName('perspective') : undefined;\nvar ua = typeof window !== 'undefined' ? window.navigator.userAgent : 'Chrome';\nvar isSafari = /Safari\\//.test(ua) && !/Chrome\\//.test(ua);\nfunction translateXY(styles, x, y) {\n    if (typeof transform !== 'undefined' && hasCSSTransforms) {\n        if (!isSafari && hasCSS3DTransforms) {\n            styles[transform] = \"translate3d(\" + x + \"px, \" + y + \"px, 0)\";\n            styles[backfaceVisibility] = 'hidden';\n        }\n        else {\n            styles[camelCase(transform)] = \"translate(\" + x + \"px, \" + y + \"px)\";\n        }\n    }\n    else {\n        styles.top = y + \"px\";\n        styles.left = x + \"px\";\n    }\n}\n\nvar DataTableBodyComponent = /** @class */ (function () {\n    /**\n     * Creates an instance of DataTableBodyComponent.\n     */\n    function DataTableBodyComponent(cd) {\n        var _this = this;\n        this.cd = cd;\n        this.selected = [];\n        this.scroll = new EventEmitter();\n        this.page = new EventEmitter();\n        this.activate = new EventEmitter();\n        this.select = new EventEmitter();\n        this.detailToggle = new EventEmitter();\n        this.rowContextmenu = new EventEmitter(false);\n        this.treeAction = new EventEmitter();\n        this.rowHeightsCache = new RowHeightCache();\n        this.temp = [];\n        this.offsetY = 0;\n        this.indexes = {};\n        this.rowIndexes = new WeakMap();\n        this.rowExpansions = [];\n        /**\n         * Get the height of the detail row.\n         */\n        this.getDetailRowHeight = function (row, index) {\n            if (!_this.rowDetail) {\n                return 0;\n            }\n            var rowHeight = _this.rowDetail.rowHeight;\n            return typeof rowHeight === 'function' ? rowHeight(row, index) : rowHeight;\n        };\n        // declare fn here so we can get access to the `this` property\n        this.rowTrackingFn = function (index, row) {\n            var idx = _this.getRowIndex(row);\n            if (_this.trackByProp) {\n                return row[_this.trackByProp];\n            }\n            else {\n                return idx;\n            }\n        };\n    }\n    Object.defineProperty(DataTableBodyComponent.prototype, \"pageSize\", {\n        get: function () {\n            return this._pageSize;\n        },\n        set: function (val) {\n            this._pageSize = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"rows\", {\n        get: function () {\n            return this._rows;\n        },\n        set: function (val) {\n            this._rows = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"columns\", {\n        get: function () {\n            return this._columns;\n        },\n        set: function (val) {\n            this._columns = val;\n            var colsByPin = columnsByPin(val);\n            this.columnGroupWidths = columnGroupWidths(colsByPin, val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"offset\", {\n        get: function () {\n            return this._offset;\n        },\n        set: function (val) {\n            this._offset = val;\n            if (!this.scrollbarV || (this.scrollbarV && !this.virtualization))\n                this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"rowCount\", {\n        get: function () {\n            return this._rowCount;\n        },\n        set: function (val) {\n            this._rowCount = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"bodyWidth\", {\n        get: function () {\n            if (this.scrollbarH) {\n                return this.innerWidth + 'px';\n            }\n            else {\n                return '100%';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"bodyHeight\", {\n        get: function () {\n            return this._bodyHeight;\n        },\n        set: function (val) {\n            if (this.scrollbarV) {\n                this._bodyHeight = val + 'px';\n            }\n            else {\n                this._bodyHeight = 'auto';\n            }\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"selectEnabled\", {\n        /**\n         * Returns if selection is enabled.\n         */\n        get: function () {\n            return !!this.selectionType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"scrollHeight\", {\n        /**\n         * Property that would calculate the height of scroll bar\n         * based on the row heights cache for virtual scroll and virtualization. Other scenarios\n         * calculate scroll height automatically (as height will be undefined).\n         */\n        get: function () {\n            if (this.scrollbarV && this.virtualization && this.rowCount) {\n                return this.rowHeightsCache.query(this.rowCount - 1);\n            }\n            // avoid TS7030: Not all code paths return a value.\n            return undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Called after the constructor, initializing input properties\n     */\n    DataTableBodyComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        if (this.rowDetail) {\n            this.listener = this.rowDetail.toggle.subscribe(function (_a) {\n                var type = _a.type, value = _a.value;\n                if (type === 'row') {\n                    _this.toggleRowExpansion(value);\n                }\n                if (type === 'all') {\n                    _this.toggleAllRows(value);\n                }\n                // Refresh rows after toggle\n                // Fixes #883\n                _this.updateIndexes();\n                _this.updateRows();\n                _this.cd.markForCheck();\n            });\n        }\n        if (this.groupHeader) {\n            this.listener = this.groupHeader.toggle.subscribe(function (_a) {\n                var type = _a.type, value = _a.value;\n                if (type === 'group') {\n                    _this.toggleRowExpansion(value);\n                }\n                if (type === 'all') {\n                    _this.toggleAllRows(value);\n                }\n                // Refresh rows after toggle\n                // Fixes #883\n                _this.updateIndexes();\n                _this.updateRows();\n                _this.cd.markForCheck();\n            });\n        }\n    };\n    /**\n     * Called once, before the instance is destroyed.\n     */\n    DataTableBodyComponent.prototype.ngOnDestroy = function () {\n        if (this.rowDetail || this.groupHeader) {\n            this.listener.unsubscribe();\n        }\n    };\n    /**\n     * Updates the Y offset given a new offset.\n     */\n    DataTableBodyComponent.prototype.updateOffsetY = function (offset) {\n        // scroller is missing on empty table\n        if (!this.scroller) {\n            return;\n        }\n        if (this.scrollbarV && this.virtualization && offset) {\n            // First get the row Index that we need to move to.\n            var rowIndex = this.pageSize * offset;\n            offset = this.rowHeightsCache.query(rowIndex - 1);\n        }\n        else if (this.scrollbarV && !this.virtualization) {\n            offset = 0;\n        }\n        this.scroller.setOffset(offset || 0);\n    };\n    /**\n     * Body was scrolled, this is mainly useful for\n     * when a user is server-side pagination via virtual scroll.\n     */\n    DataTableBodyComponent.prototype.onBodyScroll = function (event) {\n        var scrollYPos = event.scrollYPos;\n        var scrollXPos = event.scrollXPos;\n        // if scroll change, trigger update\n        // this is mainly used for header cell positions\n        if (this.offsetY !== scrollYPos || this.offsetX !== scrollXPos) {\n            this.scroll.emit({\n                offsetY: scrollYPos,\n                offsetX: scrollXPos\n            });\n        }\n        this.offsetY = scrollYPos;\n        this.offsetX = scrollXPos;\n        this.updateIndexes();\n        this.updatePage(event.direction);\n        this.updateRows();\n    };\n    /**\n     * Updates the page given a direction.\n     */\n    DataTableBodyComponent.prototype.updatePage = function (direction) {\n        var offset = this.indexes.first / this.pageSize;\n        if (direction === 'up') {\n            offset = Math.ceil(offset);\n        }\n        else if (direction === 'down') {\n            offset = Math.floor(offset);\n        }\n        if (direction !== undefined && !isNaN(offset)) {\n            this.page.emit({ offset: offset });\n        }\n    };\n    /**\n     * Updates the rows in the view port\n     */\n    DataTableBodyComponent.prototype.updateRows = function () {\n        var _this = this;\n        var _a = this.indexes, first = _a.first, last = _a.last;\n        var rowIndex = first;\n        var idx = 0;\n        var temp = [];\n        // if grouprowsby has been specified treat row paging\n        // parameters as group paging parameters ie if limit 10 has been\n        // specified treat it as 10 groups rather than 10 rows\n        if (this.groupedRows) {\n            var maxRowsPerGroup = 3;\n            // if there is only one group set the maximum number of\n            // rows per group the same as the total number of rows\n            if (this.groupedRows.length === 1) {\n                maxRowsPerGroup = this.groupedRows[0].value.length;\n            }\n            while (rowIndex < last && rowIndex < this.groupedRows.length) {\n                // Add the groups into this page\n                var group = this.groupedRows[rowIndex];\n                this.rowIndexes.set(group, rowIndex);\n                if (group.value) {\n                    // add indexes for each group item\n                    group.value.forEach(function (g, i) {\n                        var _idx = rowIndex + \"-\" + i;\n                        _this.rowIndexes.set(g, _idx);\n                    });\n                }\n                temp[idx] = group;\n                idx++;\n                // Group index in this context\n                rowIndex++;\n            }\n        }\n        else {\n            while (rowIndex < last && rowIndex < this.rowCount) {\n                var row = this.rows[rowIndex];\n                if (row) {\n                    // add indexes for each row\n                    this.rowIndexes.set(row, rowIndex);\n                    temp[idx] = row;\n                }\n                idx++;\n                rowIndex++;\n            }\n        }\n        this.temp = temp;\n    };\n    /**\n     * Get the row height\n     */\n    DataTableBodyComponent.prototype.getRowHeight = function (row) {\n        // if its a function return it\n        if (typeof this.rowHeight === 'function') {\n            return this.rowHeight(row);\n        }\n        return this.rowHeight;\n    };\n    /**\n     * @param group the group with all rows\n     */\n    DataTableBodyComponent.prototype.getGroupHeight = function (group) {\n        var rowHeight = 0;\n        if (group.value) {\n            for (var index = 0; index < group.value.length; index++) {\n                rowHeight += this.getRowAndDetailHeight(group.value[index]);\n            }\n        }\n        return rowHeight;\n    };\n    /**\n     * Calculate row height based on the expanded state of the row.\n     */\n    DataTableBodyComponent.prototype.getRowAndDetailHeight = function (row) {\n        var rowHeight = this.getRowHeight(row);\n        var expanded = this.getRowExpanded(row);\n        // Adding detail row height if its expanded.\n        if (expanded) {\n            rowHeight += this.getDetailRowHeight(row);\n        }\n        return rowHeight;\n    };\n    /**\n     * Calculates the styles for the row so that the rows can be moved in 2D space\n     * during virtual scroll inside the DOM.   In the below case the Y position is\n     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is\n     * 100 px then following styles are generated:\n     *\n     * transform: translate3d(0px, 0px, 0px);    ->  row0\n     * transform: translate3d(0px, 30px, 0px);   ->  row1\n     * transform: translate3d(0px, 130px, 0px);  ->  row2\n     *\n     * Row heights have to be calculated based on the row heights cache as we wont\n     * be able to determine which row is of what height before hand.  In the above\n     * case the positionY of the translate3d for row2 would be the sum of all the\n     * heights of the rows before it (i.e. row0 and row1).\n     *\n     * @param rows the row that needs to be placed in the 2D space.\n     * @returns the CSS3 style to be applied\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.getRowsStyles = function (rows) {\n        var styles = {};\n        // only add styles for the group if there is a group\n        if (this.groupedRows) {\n            styles.width = this.columnGroupWidths.total;\n        }\n        if (this.scrollbarV && this.virtualization) {\n            var idx = 0;\n            if (this.groupedRows) {\n                // Get the latest row rowindex in a group\n                var row = rows[rows.length - 1];\n                idx = row ? this.getRowIndex(row) : 0;\n            }\n            else {\n                idx = this.getRowIndex(rows);\n            }\n            // const pos = idx * rowHeight;\n            // The position of this row would be the sum of all row heights\n            // until the previous row position.\n            var pos = this.rowHeightsCache.query(idx - 1);\n            translateXY(styles, 0, pos);\n        }\n        return styles;\n    };\n    /**\n     * Calculate bottom summary row offset for scrollbar mode.\n     * For more information about cache and offset calculation\n     * see description for `getRowsStyles` method\n     *\n     * @returns the CSS3 style to be applied\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.getBottomSummaryRowStyles = function () {\n        if (!this.scrollbarV || !this.rows || !this.rows.length) {\n            return null;\n        }\n        var styles = { position: 'absolute' };\n        var pos = this.rowHeightsCache.query(this.rows.length - 1);\n        translateXY(styles, 0, pos);\n        return styles;\n    };\n    /**\n     * Hides the loading indicator\n     */\n    DataTableBodyComponent.prototype.hideIndicator = function () {\n        var _this = this;\n        setTimeout(function () { return (_this.loadingIndicator = false); }, 500);\n    };\n    /**\n     * Updates the index of the rows in the viewport\n     */\n    DataTableBodyComponent.prototype.updateIndexes = function () {\n        var first = 0;\n        var last = 0;\n        if (this.scrollbarV) {\n            if (this.virtualization) {\n                // Calculation of the first and last indexes will be based on where the\n                // scrollY position would be at.  The last index would be the one\n                // that shows up inside the view port the last.\n                var height = parseInt(this.bodyHeight, 0);\n                first = this.rowHeightsCache.getRowIndex(this.offsetY);\n                last = this.rowHeightsCache.getRowIndex(height + this.offsetY) + 1;\n            }\n            else {\n                // If virtual rows are not needed\n                // We render all in one go\n                first = 0;\n                last = this.rowCount;\n            }\n        }\n        else {\n            // The server is handling paging and will pass an array that begins with the\n            // element at a specified offset.  first should always be 0 with external paging.\n            if (!this.externalPaging) {\n                first = Math.max(this.offset * this.pageSize, 0);\n            }\n            last = Math.min(first + this.pageSize, this.rowCount);\n        }\n        this.indexes = { first: first, last: last };\n    };\n    /**\n     * Refreshes the full Row Height cache.  Should be used\n     * when the entire row array state has changed.\n     */\n    DataTableBodyComponent.prototype.refreshRowHeightCache = function () {\n        var e_1, _a;\n        if (!this.scrollbarV || (this.scrollbarV && !this.virtualization)) {\n            return;\n        }\n        // clear the previous row height cache if already present.\n        // this is useful during sorts, filters where the state of the\n        // rows array is changed.\n        this.rowHeightsCache.clearCache();\n        // Initialize the tree only if there are rows inside the tree.\n        if (this.rows && this.rows.length) {\n            var rowExpansions = new Set();\n            try {\n                for (var _b = __values(this.rows), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var row = _c.value;\n                    if (this.getRowExpanded(row)) {\n                        rowExpansions.add(row);\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            this.rowHeightsCache.initCache({\n                rows: this.rows,\n                rowHeight: this.rowHeight,\n                detailRowHeight: this.getDetailRowHeight,\n                externalVirtual: this.scrollbarV && this.externalPaging,\n                rowCount: this.rowCount,\n                rowIndexes: this.rowIndexes,\n                rowExpansions: rowExpansions\n            });\n        }\n    };\n    /**\n     * Gets the index for the view port\n     */\n    DataTableBodyComponent.prototype.getAdjustedViewPortIndex = function () {\n        // Capture the row index of the first row that is visible on the viewport.\n        // If the scroll bar is just below the row which is highlighted then make that as the\n        // first index.\n        var viewPortFirstRowIndex = this.indexes.first;\n        if (this.scrollbarV && this.virtualization) {\n            var offsetScroll = this.rowHeightsCache.query(viewPortFirstRowIndex - 1);\n            return offsetScroll <= this.offsetY ? viewPortFirstRowIndex - 1 : viewPortFirstRowIndex;\n        }\n        return viewPortFirstRowIndex;\n    };\n    /**\n     * Toggle the Expansion of the row i.e. if the row is expanded then it will\n     * collapse and vice versa.   Note that the expanded status is stored as\n     * a part of the row object itself as we have to preserve the expanded row\n     * status in case of sorting and filtering of the row set.\n     */\n    DataTableBodyComponent.prototype.toggleRowExpansion = function (row) {\n        // Capture the row index of the first row that is visible on the viewport.\n        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();\n        var rowExpandedIdx = this.getRowExpandedIdx(row, this.rowExpansions);\n        var expanded = rowExpandedIdx > -1;\n        // If the detailRowHeight is auto --> only in case of non-virtualized scroll\n        if (this.scrollbarV && this.virtualization) {\n            var detailRowHeight = this.getDetailRowHeight(row) * (expanded ? -1 : 1);\n            // const idx = this.rowIndexes.get(row) || 0;\n            var idx = this.getRowIndex(row);\n            this.rowHeightsCache.update(idx, detailRowHeight);\n        }\n        // Update the toggled row and update thive nevere heights in the cache.\n        if (expanded) {\n            this.rowExpansions.splice(rowExpandedIdx, 1);\n        }\n        else {\n            this.rowExpansions.push(row);\n        }\n        this.detailToggle.emit({\n            rows: [row],\n            currentIndex: viewPortFirstRowIndex\n        });\n    };\n    /**\n     * Expand/Collapse all the rows no matter what their state is.\n     */\n    DataTableBodyComponent.prototype.toggleAllRows = function (expanded) {\n        var e_2, _a;\n        // clear prev expansions\n        this.rowExpansions = [];\n        // Capture the row index of the first row that is visible on the viewport.\n        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();\n        if (expanded) {\n            try {\n                for (var _b = __values(this.rows), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var row = _c.value;\n                    this.rowExpansions.push(row);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        if (this.scrollbarV) {\n            // Refresh the full row heights cache since every row was affected.\n            this.recalcLayout();\n        }\n        // Emit all rows that have been expanded.\n        this.detailToggle.emit({\n            rows: this.rows,\n            currentIndex: viewPortFirstRowIndex\n        });\n    };\n    /**\n     * Recalculates the table\n     */\n    DataTableBodyComponent.prototype.recalcLayout = function () {\n        this.refreshRowHeightCache();\n        this.updateIndexes();\n        this.updateRows();\n    };\n    /**\n     * Tracks the column\n     */\n    DataTableBodyComponent.prototype.columnTrackingFn = function (index, column) {\n        return column.$$id;\n    };\n    /**\n     * Gets the row pinning group styles\n     */\n    DataTableBodyComponent.prototype.stylesByGroup = function (group) {\n        var widths = this.columnGroupWidths;\n        var offsetX = this.offsetX;\n        var styles = {\n            width: widths[group] + \"px\"\n        };\n        if (group === 'left') {\n            translateXY(styles, offsetX, 0);\n        }\n        else if (group === 'right') {\n            var bodyWidth = parseInt(this.innerWidth + '', 0);\n            var totalDiff = widths.total - bodyWidth;\n            var offsetDiff = totalDiff - offsetX;\n            var offset = offsetDiff * -1;\n            translateXY(styles, offset, 0);\n        }\n        return styles;\n    };\n    /**\n     * Returns if the row was expanded and set default row expansion when row expansion is empty\n     */\n    DataTableBodyComponent.prototype.getRowExpanded = function (row) {\n        var e_3, _a;\n        if (this.rowExpansions.length === 0 && this.groupExpansionDefault) {\n            try {\n                for (var _b = __values(this.groupedRows), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var group = _c.value;\n                    this.rowExpansions.push(group);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }\n        return this.getRowExpandedIdx(row, this.rowExpansions) > -1;\n    };\n    DataTableBodyComponent.prototype.getRowExpandedIdx = function (row, expanded) {\n        var _this = this;\n        if (!expanded || !expanded.length)\n            return -1;\n        var rowId = this.rowIdentity(row);\n        return expanded.findIndex(function (r) {\n            var id = _this.rowIdentity(r);\n            return id === rowId;\n        });\n    };\n    /**\n     * Gets the row index given a row\n     */\n    DataTableBodyComponent.prototype.getRowIndex = function (row) {\n        return this.rowIndexes.get(row) || 0;\n    };\n    DataTableBodyComponent.prototype.onTreeAction = function (row) {\n        this.treeAction.emit({ row: row });\n    };\n    DataTableBodyComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef }\n    ]; };\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"scrollbarV\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"scrollbarH\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"loadingIndicator\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"externalPaging\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"rowHeight\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"offsetX\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"emptyMessage\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"selectionType\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"selected\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"rowIdentity\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"rowDetail\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"groupHeader\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"selectCheck\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"displayCheck\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"trackByProp\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"rowClass\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"groupedRows\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"groupExpansionDefault\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"innerWidth\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"groupRowsBy\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"virtualization\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"summaryRow\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"summaryPosition\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"summaryHeight\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"pageSize\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"rows\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"columns\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"offset\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyComponent.prototype, \"rowCount\", null);\n    __decorate([\n        HostBinding('style.width')\n    ], DataTableBodyComponent.prototype, \"bodyWidth\", null);\n    __decorate([\n        Input(),\n        HostBinding('style.height')\n    ], DataTableBodyComponent.prototype, \"bodyHeight\", null);\n    __decorate([\n        Output()\n    ], DataTableBodyComponent.prototype, \"scroll\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyComponent.prototype, \"page\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyComponent.prototype, \"activate\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyComponent.prototype, \"select\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyComponent.prototype, \"detailToggle\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyComponent.prototype, \"rowContextmenu\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyComponent.prototype, \"treeAction\", void 0);\n    __decorate([\n        ViewChild(ScrollerComponent)\n    ], DataTableBodyComponent.prototype, \"scroller\", void 0);\n    DataTableBodyComponent = __decorate([\n        Component({\n            selector: 'datatable-body',\n            template: \"\\n    <datatable-progress *ngIf=\\\"loadingIndicator\\\"> </datatable-progress>\\n    <datatable-selection\\n      #selector\\n      [selected]=\\\"selected\\\"\\n      [rows]=\\\"rows\\\"\\n      [selectCheck]=\\\"selectCheck\\\"\\n      [selectEnabled]=\\\"selectEnabled\\\"\\n      [selectionType]=\\\"selectionType\\\"\\n      [rowIdentity]=\\\"rowIdentity\\\"\\n      (select)=\\\"select.emit($event)\\\"\\n      (activate)=\\\"activate.emit($event)\\\"\\n    >\\n      <datatable-scroller\\n        *ngIf=\\\"rows?.length\\\"\\n        [scrollbarV]=\\\"scrollbarV\\\"\\n        [scrollbarH]=\\\"scrollbarH\\\"\\n        [scrollHeight]=\\\"scrollHeight\\\"\\n        [scrollWidth]=\\\"columnGroupWidths?.total\\\"\\n        (scroll)=\\\"onBodyScroll($event)\\\"\\n      >\\n        <datatable-summary-row\\n          *ngIf=\\\"summaryRow && summaryPosition === 'top'\\\"\\n          [rowHeight]=\\\"summaryHeight\\\"\\n          [offsetX]=\\\"offsetX\\\"\\n          [innerWidth]=\\\"innerWidth\\\"\\n          [rows]=\\\"rows\\\"\\n          [columns]=\\\"columns\\\"\\n        >\\n        </datatable-summary-row>\\n        <datatable-row-wrapper\\n          [groupedRows]=\\\"groupedRows\\\"\\n          *ngFor=\\\"let group of temp; let i = index; trackBy: rowTrackingFn\\\"\\n          [innerWidth]=\\\"innerWidth\\\"\\n          [ngStyle]=\\\"getRowsStyles(group)\\\"\\n          [rowDetail]=\\\"rowDetail\\\"\\n          [groupHeader]=\\\"groupHeader\\\"\\n          [offsetX]=\\\"offsetX\\\"\\n          [detailRowHeight]=\\\"getDetailRowHeight(group && group[i], i)\\\"\\n          [row]=\\\"group\\\"\\n          [expanded]=\\\"getRowExpanded(group)\\\"\\n          [rowIndex]=\\\"getRowIndex(group && group[i])\\\"\\n          (rowContextmenu)=\\\"rowContextmenu.emit($event)\\\"\\n        >\\n          <datatable-body-row\\n            *ngIf=\\\"!groupedRows; else groupedRowsTemplate\\\"\\n            tabindex=\\\"-1\\\"\\n            [isSelected]=\\\"selector.getRowSelected(group)\\\"\\n            [innerWidth]=\\\"innerWidth\\\"\\n            [offsetX]=\\\"offsetX\\\"\\n            [columns]=\\\"columns\\\"\\n            [rowHeight]=\\\"getRowHeight(group)\\\"\\n            [row]=\\\"group\\\"\\n            [rowIndex]=\\\"getRowIndex(group)\\\"\\n            [expanded]=\\\"getRowExpanded(group)\\\"\\n            [rowClass]=\\\"rowClass\\\"\\n            [displayCheck]=\\\"displayCheck\\\"\\n            [treeStatus]=\\\"group && group.treeStatus\\\"\\n            (treeAction)=\\\"onTreeAction(group)\\\"\\n            (activate)=\\\"selector.onActivate($event, indexes.first + i)\\\"\\n          >\\n          </datatable-body-row>\\n          <ng-template #groupedRowsTemplate>\\n            <datatable-body-row\\n              *ngFor=\\\"let row of group.value; let i = index; trackBy: rowTrackingFn\\\"\\n              tabindex=\\\"-1\\\"\\n              [isSelected]=\\\"selector.getRowSelected(row)\\\"\\n              [innerWidth]=\\\"innerWidth\\\"\\n              [offsetX]=\\\"offsetX\\\"\\n              [columns]=\\\"columns\\\"\\n              [rowHeight]=\\\"getRowHeight(row)\\\"\\n              [row]=\\\"row\\\"\\n              [group]=\\\"group.value\\\"\\n              [rowIndex]=\\\"getRowIndex(row)\\\"\\n              [expanded]=\\\"getRowExpanded(row)\\\"\\n              [rowClass]=\\\"rowClass\\\"\\n              (activate)=\\\"selector.onActivate($event, i)\\\"\\n            >\\n            </datatable-body-row>\\n          </ng-template>\\n        </datatable-row-wrapper>\\n        <datatable-summary-row\\n          *ngIf=\\\"summaryRow && summaryPosition === 'bottom'\\\"\\n          [ngStyle]=\\\"getBottomSummaryRowStyles()\\\"\\n          [rowHeight]=\\\"summaryHeight\\\"\\n          [offsetX]=\\\"offsetX\\\"\\n          [innerWidth]=\\\"innerWidth\\\"\\n          [rows]=\\\"rows\\\"\\n          [columns]=\\\"columns\\\"\\n        >\\n        </datatable-summary-row>\\n      </datatable-scroller>\\n      <div class=\\\"empty-row\\\" *ngIf=\\\"!rows?.length && !loadingIndicator\\\" [innerHTML]=\\\"emptyMessage\\\"></div>\\n    </datatable-selection>\\n  \",\n            changeDetection: ChangeDetectionStrategy.OnPush,\n            host: {\n                class: 'datatable-body'\n            }\n        })\n    ], DataTableBodyComponent);\n    return DataTableBodyComponent;\n}());\n\nvar DataTableHeaderComponent = /** @class */ (function () {\n    function DataTableHeaderComponent(cd) {\n        this.cd = cd;\n        this.sort = new EventEmitter();\n        this.reorder = new EventEmitter();\n        this.resize = new EventEmitter();\n        this.select = new EventEmitter();\n        this.columnContextmenu = new EventEmitter(false);\n        this._columnGroupWidths = {\n            total: 100\n        };\n        this._styleByGroup = {\n            left: {},\n            center: {},\n            right: {}\n        };\n        this.destroyed = false;\n    }\n    Object.defineProperty(DataTableHeaderComponent.prototype, \"innerWidth\", {\n        get: function () {\n            return this._innerWidth;\n        },\n        set: function (val) {\n            var _this = this;\n            this._innerWidth = val;\n            setTimeout(function () {\n                if (_this._columns) {\n                    var colByPin = columnsByPin(_this._columns);\n                    _this._columnGroupWidths = columnGroupWidths(colByPin, _this._columns);\n                    _this.setStylesByGroup();\n                }\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderComponent.prototype, \"headerHeight\", {\n        get: function () {\n            return this._headerHeight;\n        },\n        set: function (val) {\n            if (val !== 'auto') {\n                this._headerHeight = val + \"px\";\n            }\n            else {\n                this._headerHeight = val;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderComponent.prototype, \"columns\", {\n        get: function () {\n            return this._columns;\n        },\n        set: function (val) {\n            var _this = this;\n            this._columns = val;\n            var colsByPin = columnsByPin(val);\n            this._columnsByPin = columnsByPinArr(val);\n            setTimeout(function () {\n                _this._columnGroupWidths = columnGroupWidths(colsByPin, val);\n                _this.setStylesByGroup();\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderComponent.prototype, \"offsetX\", {\n        get: function () {\n            return this._offsetX;\n        },\n        set: function (val) {\n            this._offsetX = val;\n            this.setStylesByGroup();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTableHeaderComponent.prototype.ngOnDestroy = function () {\n        this.destroyed = true;\n    };\n    DataTableHeaderComponent.prototype.onLongPressStart = function (_a) {\n        var event = _a.event, model = _a.model;\n        model.dragging = true;\n        this.dragEventTarget = event;\n    };\n    DataTableHeaderComponent.prototype.onLongPressEnd = function (_a) {\n        var _this = this;\n        var event = _a.event, model = _a.model;\n        this.dragEventTarget = event;\n        // delay resetting so sort can be\n        // prevented if we were dragging\n        setTimeout(function () {\n            // datatable component creates copies from columns on reorder\n            // set dragging to false on new objects\n            var column = _this._columns.find(function (c) { return c.$$id === model.$$id; });\n            if (column) {\n                column.dragging = false;\n            }\n        }, 5);\n    };\n    Object.defineProperty(DataTableHeaderComponent.prototype, \"headerWidth\", {\n        get: function () {\n            if (this.scrollbarH) {\n                return this.innerWidth + 'px';\n            }\n            return '100%';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTableHeaderComponent.prototype.trackByGroups = function (index, colGroup) {\n        return colGroup.type;\n    };\n    DataTableHeaderComponent.prototype.columnTrackingFn = function (index, column) {\n        return column.$$id;\n    };\n    DataTableHeaderComponent.prototype.onColumnResized = function (width, column) {\n        if (width <= column.minWidth) {\n            width = column.minWidth;\n        }\n        else if (width >= column.maxWidth) {\n            width = column.maxWidth;\n        }\n        this.resize.emit({\n            column: column,\n            prevValue: column.width,\n            newValue: width\n        });\n    };\n    DataTableHeaderComponent.prototype.onColumnReordered = function (_a) {\n        var prevIndex = _a.prevIndex, newIndex = _a.newIndex, model = _a.model;\n        var column = this.getColumn(newIndex);\n        column.isTarget = false;\n        column.targetMarkerContext = undefined;\n        this.reorder.emit({\n            column: model,\n            prevValue: prevIndex,\n            newValue: newIndex\n        });\n    };\n    DataTableHeaderComponent.prototype.onTargetChanged = function (_a) {\n        var prevIndex = _a.prevIndex, newIndex = _a.newIndex, initialIndex = _a.initialIndex;\n        if (prevIndex || prevIndex === 0) {\n            var oldColumn = this.getColumn(prevIndex);\n            oldColumn.isTarget = false;\n            oldColumn.targetMarkerContext = undefined;\n        }\n        if (newIndex || newIndex === 0) {\n            var newColumn = this.getColumn(newIndex);\n            newColumn.isTarget = true;\n            if (initialIndex !== newIndex) {\n                newColumn.targetMarkerContext = {\n                    class: 'targetMarker '.concat(initialIndex > newIndex ? 'dragFromRight' : 'dragFromLeft')\n                };\n            }\n        }\n    };\n    DataTableHeaderComponent.prototype.getColumn = function (index) {\n        var leftColumnCount = this._columnsByPin[0].columns.length;\n        if (index < leftColumnCount) {\n            return this._columnsByPin[0].columns[index];\n        }\n        var centerColumnCount = this._columnsByPin[1].columns.length;\n        if (index < leftColumnCount + centerColumnCount) {\n            return this._columnsByPin[1].columns[index - leftColumnCount];\n        }\n        return this._columnsByPin[2].columns[index - leftColumnCount - centerColumnCount];\n    };\n    DataTableHeaderComponent.prototype.onSort = function (_a) {\n        var column = _a.column, prevValue = _a.prevValue, newValue = _a.newValue;\n        // if we are dragging don't sort!\n        if (column.dragging) {\n            return;\n        }\n        var sorts = this.calcNewSorts(column, prevValue, newValue);\n        this.sort.emit({\n            sorts: sorts,\n            column: column,\n            prevValue: prevValue,\n            newValue: newValue\n        });\n    };\n    DataTableHeaderComponent.prototype.calcNewSorts = function (column, prevValue, newValue) {\n        var idx = 0;\n        if (!this.sorts) {\n            this.sorts = [];\n        }\n        var sorts = this.sorts.map(function (s, i) {\n            s = __assign({}, s);\n            if (s.prop === column.prop) {\n                idx = i;\n            }\n            return s;\n        });\n        if (newValue === undefined) {\n            sorts.splice(idx, 1);\n        }\n        else if (prevValue) {\n            sorts[idx].dir = newValue;\n        }\n        else {\n            if (this.sortType === SortType.single) {\n                sorts.splice(0, this.sorts.length);\n            }\n            sorts.push({ dir: newValue, prop: column.prop });\n        }\n        return sorts;\n    };\n    DataTableHeaderComponent.prototype.setStylesByGroup = function () {\n        this._styleByGroup.left = this.calcStylesByGroup('left');\n        this._styleByGroup.center = this.calcStylesByGroup('center');\n        this._styleByGroup.right = this.calcStylesByGroup('right');\n        if (!this.destroyed) {\n            this.cd.detectChanges();\n        }\n    };\n    DataTableHeaderComponent.prototype.calcStylesByGroup = function (group) {\n        var widths = this._columnGroupWidths;\n        var offsetX = this.offsetX;\n        var styles = {\n            width: widths[group] + \"px\"\n        };\n        if (group === 'center') {\n            translateXY(styles, offsetX * -1, 0);\n        }\n        else if (group === 'right') {\n            var totalDiff = widths.total - this.innerWidth;\n            var offset = totalDiff * -1;\n            translateXY(styles, offset, 0);\n        }\n        return styles;\n    };\n    DataTableHeaderComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef }\n    ]; };\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"sortAscendingIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"sortDescendingIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"sortUnsetIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"scrollbarH\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"dealsWithGroup\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"targetMarkerTemplate\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"innerWidth\", null);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"sorts\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"sortType\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"allRowsSelected\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"selectionType\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"reorderable\", void 0);\n    __decorate([\n        HostBinding('style.height'),\n        Input()\n    ], DataTableHeaderComponent.prototype, \"headerHeight\", null);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"columns\", null);\n    __decorate([\n        Input()\n    ], DataTableHeaderComponent.prototype, \"offsetX\", null);\n    __decorate([\n        Output()\n    ], DataTableHeaderComponent.prototype, \"sort\", void 0);\n    __decorate([\n        Output()\n    ], DataTableHeaderComponent.prototype, \"reorder\", void 0);\n    __decorate([\n        Output()\n    ], DataTableHeaderComponent.prototype, \"resize\", void 0);\n    __decorate([\n        Output()\n    ], DataTableHeaderComponent.prototype, \"select\", void 0);\n    __decorate([\n        Output()\n    ], DataTableHeaderComponent.prototype, \"columnContextmenu\", void 0);\n    __decorate([\n        HostBinding('style.width')\n    ], DataTableHeaderComponent.prototype, \"headerWidth\", null);\n    DataTableHeaderComponent = __decorate([\n        Component({\n            selector: 'datatable-header',\n            template: \"\\n    <div\\n      orderable\\n      (reorder)=\\\"onColumnReordered($event)\\\"\\n      (targetChanged)=\\\"onTargetChanged($event)\\\"\\n      [style.width.px]=\\\"_columnGroupWidths.total\\\"\\n      class=\\\"datatable-header-inner\\\"\\n    >\\n      <div\\n        *ngFor=\\\"let colGroup of _columnsByPin; trackBy: trackByGroups\\\"\\n        [class]=\\\"'datatable-row-' + colGroup.type\\\"\\n        [ngStyle]=\\\"_styleByGroup[colGroup.type]\\\"\\n      >\\n        <datatable-header-cell\\n          *ngFor=\\\"let column of colGroup.columns; trackBy: columnTrackingFn\\\"\\n          resizeable\\n          [resizeEnabled]=\\\"column.resizeable\\\"\\n          (resize)=\\\"onColumnResized($event, column)\\\"\\n          long-press\\n          [pressModel]=\\\"column\\\"\\n          [pressEnabled]=\\\"reorderable && column.draggable\\\"\\n          (longPressStart)=\\\"onLongPressStart($event)\\\"\\n          (longPressEnd)=\\\"onLongPressEnd($event)\\\"\\n          draggable\\n          [dragX]=\\\"reorderable && column.draggable && column.dragging\\\"\\n          [dragY]=\\\"false\\\"\\n          [dragModel]=\\\"column\\\"\\n          [dragEventTarget]=\\\"dragEventTarget\\\"\\n          [headerHeight]=\\\"headerHeight\\\"\\n          [isTarget]=\\\"column.isTarget\\\"\\n          [targetMarkerTemplate]=\\\"targetMarkerTemplate\\\"\\n          [targetMarkerContext]=\\\"column.targetMarkerContext\\\"\\n          [column]=\\\"column\\\"\\n          [sortType]=\\\"sortType\\\"\\n          [sorts]=\\\"sorts\\\"\\n          [selectionType]=\\\"selectionType\\\"\\n          [sortAscendingIcon]=\\\"sortAscendingIcon\\\"\\n          [sortDescendingIcon]=\\\"sortDescendingIcon\\\"\\n          [sortUnsetIcon]=\\\"sortUnsetIcon\\\"\\n          [allRowsSelected]=\\\"allRowsSelected\\\"\\n          (sort)=\\\"onSort($event)\\\"\\n          (select)=\\\"select.emit($event)\\\"\\n          (columnContextmenu)=\\\"columnContextmenu.emit($event)\\\"\\n        >\\n        </datatable-header-cell>\\n      </div>\\n    </div>\\n  \",\n            host: {\n                class: 'datatable-header'\n            },\n            changeDetection: ChangeDetectionStrategy.OnPush\n        })\n    ], DataTableHeaderComponent);\n    return DataTableHeaderComponent;\n}());\n\n/**\n * Throttle a function\n */\nfunction throttle(func, wait, options) {\n    options = options || {};\n    var context;\n    var args;\n    var result;\n    var timeout = null;\n    var previous = 0;\n    function later() {\n        previous = options.leading === false ? 0 : +new Date();\n        timeout = null;\n        result = func.apply(context, args);\n    }\n    return function () {\n        var now = +new Date();\n        if (!previous && options.leading === false) {\n            previous = now;\n        }\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0) {\n            clearTimeout(timeout);\n            timeout = null;\n            previous = now;\n            result = func.apply(context, args);\n        }\n        else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\n/**\n * Throttle decorator\n *\n *  class MyClass {\n *    throttleable(10)\n *    myFn() { ... }\n *  }\n */\nfunction throttleable(duration, options) {\n    return function innerDecorator(target, key, descriptor) {\n        return {\n            configurable: true,\n            enumerable: descriptor.enumerable,\n            get: function getter() {\n                Object.defineProperty(this, key, {\n                    configurable: true,\n                    enumerable: descriptor.enumerable,\n                    value: throttle(descriptor.value, duration, options)\n                });\n                return this[key];\n            }\n        };\n    };\n}\n\n/**\n * Calculates the Total Flex Grow\n */\nfunction getTotalFlexGrow(columns) {\n    var e_1, _a;\n    var totalFlexGrow = 0;\n    try {\n        for (var columns_1 = __values(columns), columns_1_1 = columns_1.next(); !columns_1_1.done; columns_1_1 = columns_1.next()) {\n            var c = columns_1_1.value;\n            totalFlexGrow += c.flexGrow || 0;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (columns_1_1 && !columns_1_1.done && (_a = columns_1.return)) _a.call(columns_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return totalFlexGrow;\n}\n/**\n * Adjusts the column widths.\n * Inspired by: https://github.com/facebook/fixed-data-table/blob/master/src/FixedDataTableWidthHelper.js\n */\nfunction adjustColumnWidths(allColumns, expectedWidth) {\n    var columnsWidth = columnsTotalWidth(allColumns);\n    var totalFlexGrow = getTotalFlexGrow(allColumns);\n    var colsByGroup = columnsByPin(allColumns);\n    if (columnsWidth !== expectedWidth) {\n        scaleColumns(colsByGroup, expectedWidth, totalFlexGrow);\n    }\n}\n/**\n * Resizes columns based on the flexGrow property, while respecting manually set widths\n */\nfunction scaleColumns(colsByGroup, maxWidth, totalFlexGrow) {\n    var e_2, _a, e_3, _b;\n    // calculate total width and flexgrow points for coulumns that can be resized\n    for (var attr in colsByGroup) {\n        try {\n            for (var _c = (e_2 = void 0, __values(colsByGroup[attr])), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var column = _d.value;\n                if (!column.canAutoResize) {\n                    maxWidth -= column.width;\n                    totalFlexGrow -= column.flexGrow ? column.flexGrow : 0;\n                }\n                else {\n                    column.width = 0;\n                }\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    }\n    var hasMinWidth = {};\n    var remainingWidth = maxWidth;\n    // resize columns until no width is left to be distributed\n    do {\n        var widthPerFlexPoint = remainingWidth / totalFlexGrow;\n        remainingWidth = 0;\n        for (var attr in colsByGroup) {\n            try {\n                for (var _e = (e_3 = void 0, __values(colsByGroup[attr])), _f = _e.next(); !_f.done; _f = _e.next()) {\n                    var column = _f.value;\n                    // if the column can be resize and it hasn't reached its minimum width yet\n                    if (column.canAutoResize && !hasMinWidth[column.prop]) {\n                        var newWidth = column.width + column.flexGrow * widthPerFlexPoint;\n                        if (column.minWidth !== undefined && newWidth < column.minWidth) {\n                            remainingWidth += newWidth - column.minWidth;\n                            column.width = column.minWidth;\n                            hasMinWidth[column.prop] = true;\n                        }\n                        else {\n                            column.width = newWidth;\n                        }\n                    }\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }\n    } while (remainingWidth !== 0);\n}\n/**\n * Forces the width of the columns to\n * distribute equally but overflowing when necessary\n *\n * Rules:\n *\n *  - If combined withs are less than the total width of the grid,\n *    proportion the widths given the min / max / normal widths to fill the width.\n *\n *  - If the combined widths, exceed the total width of the grid,\n *    use the standard widths.\n *\n *  - If a column is resized, it should always use that width\n *\n *  - The proportional widths should never fall below min size if specified.\n *\n *  - If the grid starts off small but then becomes greater than the size ( + / - )\n *    the width should use the original width; not the newly proportioned widths.\n */\nfunction forceFillColumnWidths(allColumns, expectedWidth, startIdx, allowBleed, defaultColWidth) {\n    var e_4, _a, e_5, _b;\n    if (defaultColWidth === void 0) { defaultColWidth = 300; }\n    var columnsToResize = allColumns.slice(startIdx + 1, allColumns.length).filter(function (c) {\n        return c.canAutoResize !== false;\n    });\n    try {\n        for (var columnsToResize_1 = __values(columnsToResize), columnsToResize_1_1 = columnsToResize_1.next(); !columnsToResize_1_1.done; columnsToResize_1_1 = columnsToResize_1.next()) {\n            var column = columnsToResize_1_1.value;\n            if (!column.$$oldWidth) {\n                column.$$oldWidth = column.width;\n            }\n        }\n    }\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n    finally {\n        try {\n            if (columnsToResize_1_1 && !columnsToResize_1_1.done && (_a = columnsToResize_1.return)) _a.call(columnsToResize_1);\n        }\n        finally { if (e_4) throw e_4.error; }\n    }\n    var additionWidthPerColumn = 0;\n    var exceedsWindow = false;\n    var contentWidth = getContentWidth(allColumns, defaultColWidth);\n    var remainingWidth = expectedWidth - contentWidth;\n    var columnsProcessed = [];\n    var remainingWidthLimit = 1; // when to stop\n    // This loop takes care of the\n    do {\n        additionWidthPerColumn = remainingWidth / columnsToResize.length;\n        exceedsWindow = contentWidth >= expectedWidth;\n        try {\n            for (var columnsToResize_2 = (e_5 = void 0, __values(columnsToResize)), columnsToResize_2_1 = columnsToResize_2.next(); !columnsToResize_2_1.done; columnsToResize_2_1 = columnsToResize_2.next()) {\n                var column = columnsToResize_2_1.value;\n                if (exceedsWindow && allowBleed) {\n                    column.width = column.$$oldWidth || column.width || defaultColWidth;\n                }\n                else {\n                    var newSize = (column.width || defaultColWidth) + additionWidthPerColumn;\n                    if (column.minWidth && newSize < column.minWidth) {\n                        column.width = column.minWidth;\n                        columnsProcessed.push(column);\n                    }\n                    else if (column.maxWidth && newSize > column.maxWidth) {\n                        column.width = column.maxWidth;\n                        columnsProcessed.push(column);\n                    }\n                    else {\n                        column.width = newSize;\n                    }\n                }\n                column.width = Math.max(0, column.width);\n            }\n        }\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\n        finally {\n            try {\n                if (columnsToResize_2_1 && !columnsToResize_2_1.done && (_b = columnsToResize_2.return)) _b.call(columnsToResize_2);\n            }\n            finally { if (e_5) throw e_5.error; }\n        }\n        contentWidth = getContentWidth(allColumns);\n        remainingWidth = expectedWidth - contentWidth;\n        removeProcessedColumns(columnsToResize, columnsProcessed);\n    } while (remainingWidth > remainingWidthLimit && columnsToResize.length !== 0);\n}\n/**\n * Remove the processed columns from the current active columns.\n */\nfunction removeProcessedColumns(columnsToResize, columnsProcessed) {\n    var e_6, _a;\n    try {\n        for (var columnsProcessed_1 = __values(columnsProcessed), columnsProcessed_1_1 = columnsProcessed_1.next(); !columnsProcessed_1_1.done; columnsProcessed_1_1 = columnsProcessed_1.next()) {\n            var column = columnsProcessed_1_1.value;\n            var index = columnsToResize.indexOf(column);\n            columnsToResize.splice(index, 1);\n        }\n    }\n    catch (e_6_1) { e_6 = { error: e_6_1 }; }\n    finally {\n        try {\n            if (columnsProcessed_1_1 && !columnsProcessed_1_1.done && (_a = columnsProcessed_1.return)) _a.call(columnsProcessed_1);\n        }\n        finally { if (e_6) throw e_6.error; }\n    }\n}\n/**\n * Gets the width of the columns\n */\nfunction getContentWidth(allColumns, defaultColWidth) {\n    var e_7, _a;\n    if (defaultColWidth === void 0) { defaultColWidth = 300; }\n    var contentWidth = 0;\n    try {\n        for (var allColumns_1 = __values(allColumns), allColumns_1_1 = allColumns_1.next(); !allColumns_1_1.done; allColumns_1_1 = allColumns_1.next()) {\n            var column = allColumns_1_1.value;\n            contentWidth += column.width || defaultColWidth;\n        }\n    }\n    catch (e_7_1) { e_7 = { error: e_7_1 }; }\n    finally {\n        try {\n            if (allColumns_1_1 && !allColumns_1_1.done && (_a = allColumns_1.return)) _a.call(allColumns_1);\n        }\n        finally { if (e_7) throw e_7.error; }\n    }\n    return contentWidth;\n}\n\nvar SortDirection;\n(function (SortDirection) {\n    SortDirection[\"asc\"] = \"asc\";\n    SortDirection[\"desc\"] = \"desc\";\n})(SortDirection || (SortDirection = {}));\n\n/**\n * Gets the next sort direction\n */\nfunction nextSortDir(sortType, current) {\n    if (sortType === SortType.single) {\n        if (current === SortDirection.asc) {\n            return SortDirection.desc;\n        }\n        else {\n            return SortDirection.asc;\n        }\n    }\n    else {\n        if (!current) {\n            return SortDirection.asc;\n        }\n        else if (current === SortDirection.asc) {\n            return SortDirection.desc;\n        }\n        else if (current === SortDirection.desc) {\n            return undefined;\n        }\n        // avoid TS7030: Not all code paths return a value.\n        return undefined;\n    }\n}\n/**\n * Adapted from fueld-ui on 6/216\n * https://github.com/FuelInteractive/fuel-ui/tree/master/src/pipes/OrderBy\n */\nfunction orderByComparator(a, b) {\n    if (a === null || typeof a === 'undefined')\n        a = 0;\n    if (b === null || typeof b === 'undefined')\n        b = 0;\n    if (a instanceof Date && b instanceof Date) {\n        if (a < b)\n            return -1;\n        if (a > b)\n            return 1;\n    }\n    else if (isNaN(parseFloat(a)) || !isFinite(a) || isNaN(parseFloat(b)) || !isFinite(b)) {\n        // Convert to string in case of a=0 or b=0\n        a = String(a);\n        b = String(b);\n        // Isn't a number so lowercase the string to properly compare\n        if (a.toLowerCase() < b.toLowerCase())\n            return -1;\n        if (a.toLowerCase() > b.toLowerCase())\n            return 1;\n    }\n    else {\n        // Parse strings as numbers to compare properly\n        if (parseFloat(a) < parseFloat(b))\n            return -1;\n        if (parseFloat(a) > parseFloat(b))\n            return 1;\n    }\n    // equal each other\n    return 0;\n}\n/**\n * creates a shallow copy of the `rows` input and returns the sorted copy. this function\n * does not sort the `rows` argument in place\n */\nfunction sortRows(rows, columns, dirs) {\n    if (!rows)\n        return [];\n    if (!dirs || !dirs.length || !columns)\n        return __spread(rows);\n    /**\n     * record the row ordering of results from prior sort operations (if applicable)\n     * this is necessary to guarantee stable sorting behavior\n     */\n    var rowToIndexMap = new Map();\n    rows.forEach(function (row, index) { return rowToIndexMap.set(row, index); });\n    var temp = __spread(rows);\n    var cols = columns.reduce(function (obj, col) {\n        if (col.comparator && typeof col.comparator === 'function') {\n            obj[col.prop] = col.comparator;\n        }\n        return obj;\n    }, {});\n    // cache valueGetter and compareFn so that they\n    // do not need to be looked-up in the sort function body\n    var cachedDirs = dirs.map(function (dir) {\n        var prop = dir.prop;\n        return {\n            prop: prop,\n            dir: dir.dir,\n            valueGetter: getterForProp(prop),\n            compareFn: cols[prop] || orderByComparator\n        };\n    });\n    return temp.sort(function (rowA, rowB) {\n        var e_1, _a;\n        try {\n            for (var cachedDirs_1 = __values(cachedDirs), cachedDirs_1_1 = cachedDirs_1.next(); !cachedDirs_1_1.done; cachedDirs_1_1 = cachedDirs_1.next()) {\n                var cachedDir = cachedDirs_1_1.value;\n                // Get property and valuegetters for column to be sorted\n                var prop = cachedDir.prop, valueGetter = cachedDir.valueGetter;\n                // Get A and B cell values from rows based on properties of the columns\n                var propA = valueGetter(rowA, prop);\n                var propB = valueGetter(rowB, prop);\n                // Compare function gets five parameters:\n                // Two cell values to be compared as propA and propB\n                // Two rows corresponding to the cells as rowA and rowB\n                // Direction of the sort for this column as SortDirection\n                // Compare can be a standard JS comparison function (a,b) => -1|0|1\n                // as additional parameters are silently ignored. The whole row and sort\n                // direction enable more complex sort logic.\n                var comparison = cachedDir.dir !== SortDirection.desc\n                    ? cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir)\n                    : -cachedDir.compareFn(propA, propB, rowA, rowB, cachedDir.dir);\n                // Don't return 0 yet in case of needing to sort by next property\n                if (comparison !== 0)\n                    return comparison;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (cachedDirs_1_1 && !cachedDirs_1_1.done && (_a = cachedDirs_1.return)) _a.call(cachedDirs_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (!(rowToIndexMap.has(rowA) && rowToIndexMap.has(rowB)))\n            return 0;\n        /**\n         * all else being equal, preserve original order of the rows (stable sort)\n         */\n        return rowToIndexMap.get(rowA) < rowToIndexMap.get(rowB) ? -1 : 1;\n    });\n}\n\nvar DatatableComponent = /** @class */ (function () {\n    function DatatableComponent(scrollbarHelper, dimensionsHelper, cd, element, differs, columnChangesService, configuration) {\n        var _this = this;\n        this.scrollbarHelper = scrollbarHelper;\n        this.dimensionsHelper = dimensionsHelper;\n        this.cd = cd;\n        this.columnChangesService = columnChangesService;\n        this.configuration = configuration;\n        /**\n         * List of row objects that should be\n         * represented as selected in the grid.\n         * Default value: `[]`\n         */\n        this.selected = [];\n        /**\n         * Enable vertical scrollbars\n         */\n        this.scrollbarV = false;\n        /**\n         * Enable horz scrollbars\n         */\n        this.scrollbarH = false;\n        /**\n         * The row height; which is necessary\n         * to calculate the height for the lazy rendering.\n         */\n        this.rowHeight = 30;\n        /**\n         * Type of column width distribution formula.\n         * Example: flex, force, standard\n         */\n        this.columnMode = ColumnMode.standard;\n        /**\n         * The minimum header height in pixels.\n         * Pass a falsey for no header\n         */\n        this.headerHeight = 30;\n        /**\n         * The minimum footer height in pixels.\n         * Pass falsey for no footer\n         */\n        this.footerHeight = 0;\n        /**\n         * If the table should use external paging\n         * otherwise its assumed that all data is preloaded.\n         */\n        this.externalPaging = false;\n        /**\n         * If the table should use external sorting or\n         * the built-in basic sorting.\n         */\n        this.externalSorting = false;\n        /**\n         * Show the linear loading bar.\n         * Default value: `false`\n         */\n        this.loadingIndicator = false;\n        /**\n         * Enable/Disable ability to re-order columns\n         * by dragging them.\n         */\n        this.reorderable = true;\n        /**\n         * Swap columns on re-order columns or\n         * move them.\n         */\n        this.swapColumns = true;\n        /**\n         * The type of sorting\n         */\n        this.sortType = SortType.single;\n        /**\n         * Array of sorted columns by property and type.\n         * Default value: `[]`\n         */\n        this.sorts = [];\n        /**\n         * Css class overrides\n         */\n        this.cssClasses = {\n            sortAscending: 'datatable-icon-up',\n            sortDescending: 'datatable-icon-down',\n            sortUnset: 'datatable-icon-sort-unset',\n            pagerLeftArrow: 'datatable-icon-left',\n            pagerRightArrow: 'datatable-icon-right',\n            pagerPrevious: 'datatable-icon-prev',\n            pagerNext: 'datatable-icon-skip'\n        };\n        /**\n         * Message overrides for localization\n         *\n         * emptyMessage     [default] = 'No data to display'\n         * totalMessage     [default] = 'total'\n         * selectedMessage  [default] = 'selected'\n         */\n        this.messages = {\n            // Message to show when array is presented\n            // but contains no values\n            emptyMessage: 'No data to display',\n            // Footer total message\n            totalMessage: 'total',\n            // Footer selected message\n            selectedMessage: 'selected'\n        };\n        /**\n         * A boolean you can use to set the detault behaviour of rows and groups\n         * whether they will start expanded or not. If ommited the default is NOT expanded.\n         *\n         */\n        this.groupExpansionDefault = false;\n        /**\n         * Property to which you can use for determining select all\n         * rows on current page or not.\n         *\n         * @memberOf DatatableComponent\n         */\n        this.selectAllRowsOnPage = false;\n        /**\n         * A flag for row virtualization on / off\n         */\n        this.virtualization = true;\n        /**\n         * A flag for switching summary row on / off\n         */\n        this.summaryRow = false;\n        /**\n         * A height of summary row\n         */\n        this.summaryHeight = 30;\n        /**\n         * A property holds a summary row position: top/bottom\n         */\n        this.summaryPosition = 'top';\n        /**\n         * Body was scrolled typically in a `scrollbarV:true` scenario.\n         */\n        this.scroll = new EventEmitter();\n        /**\n         * A cell or row was focused via keyboard or mouse click.\n         */\n        this.activate = new EventEmitter();\n        /**\n         * A cell or row was selected.\n         */\n        this.select = new EventEmitter();\n        /**\n         * Column sort was invoked.\n         */\n        this.sort = new EventEmitter();\n        /**\n         * The table was paged either triggered by the pager or the body scroll.\n         */\n        this.page = new EventEmitter();\n        /**\n         * Columns were re-ordered.\n         */\n        this.reorder = new EventEmitter();\n        /**\n         * Column was resized.\n         */\n        this.resize = new EventEmitter();\n        /**\n         * The context menu was invoked on the table.\n         * type indicates whether the header or the body was clicked.\n         * content contains either the column or the row that was clicked.\n         */\n        this.tableContextmenu = new EventEmitter(false);\n        /**\n         * A row was expanded ot collapsed for tree\n         */\n        this.treeAction = new EventEmitter();\n        this.rowCount = 0;\n        this._offsetX = new BehaviorSubject(0);\n        this._count = 0;\n        this._offset = 0;\n        this._subscriptions = [];\n        /**\n         * This will be used when displaying or selecting rows.\n         * when tracking/comparing them, we'll use the value of this fn,\n         *\n         * (`fn(x) === fn(y)` instead of `x === y`)\n         */\n        this.rowIdentity = function (x) {\n            if (_this._groupRowsBy) {\n                // each group in groupedRows are stored as {key, value: [rows]},\n                // where key is the groupRowsBy index\n                return x.key;\n            }\n            else {\n                return x;\n            }\n        };\n        // get ref to elm for measuring\n        this.element = element.nativeElement;\n        this.rowDiffer = differs.find({}).create();\n        // apply global settings from Module.forRoot\n        if (this.configuration && this.configuration.messages) {\n            this.messages = __assign({}, this.configuration.messages);\n        }\n    }\n    Object.defineProperty(DatatableComponent.prototype, \"rows\", {\n        /**\n         * Gets the rows.\n         */\n        get: function () {\n            return this._rows;\n        },\n        /**\n         * Rows that are displayed in the table.\n         */\n        set: function (val) {\n            this._rows = val;\n            if (val) {\n                this._internalRows = __spread(val);\n            }\n            // auto sort on new updates\n            if (!this.externalSorting) {\n                this.sortInternalRows();\n            }\n            // auto group by parent on new update\n            this._internalRows = groupRowsByParents(this._internalRows, optionalGetterForProp(this.treeFromRelation), optionalGetterForProp(this.treeToRelation));\n            // recalculate sizes/etc\n            this.recalculate();\n            if (this._rows && this._groupRowsBy) {\n                // If a column has been specified in _groupRowsBy created a new array with the data grouped by that row\n                this.groupedRows = this.groupArrayBy(this._rows, this._groupRowsBy);\n            }\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"groupRowsBy\", {\n        get: function () {\n            return this._groupRowsBy;\n        },\n        /**\n         * This attribute allows the user to set the name of the column to group the data with\n         */\n        set: function (val) {\n            if (val) {\n                this._groupRowsBy = val;\n                if (this._rows && this._groupRowsBy) {\n                    // cretes a new array with the data grouped\n                    this.groupedRows = this.groupArrayBy(this._rows, this._groupRowsBy);\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"columns\", {\n        /**\n         * Get the columns.\n         */\n        get: function () {\n            return this._columns;\n        },\n        /**\n         * Columns to be displayed.\n         */\n        set: function (val) {\n            if (val) {\n                this._internalColumns = __spread(val);\n                setColumnDefaults(this._internalColumns);\n                this.recalculateColumns();\n            }\n            this._columns = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"limit\", {\n        /**\n         * Gets the limit.\n         */\n        get: function () {\n            return this._limit;\n        },\n        /**\n         * The page size to be shown.\n         * Default value: `undefined`\n         */\n        set: function (val) {\n            this._limit = val;\n            // recalculate sizes/etc\n            this.recalculate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"count\", {\n        /**\n         * Gets the count.\n         */\n        get: function () {\n            return this._count;\n        },\n        /**\n         * The total count of all rows.\n         * Default value: `0`\n         */\n        set: function (val) {\n            this._count = val;\n            // recalculate sizes/etc\n            this.recalculate();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"offset\", {\n        get: function () {\n            return Math.max(Math.min(this._offset, Math.ceil(this.rowCount / this.pageSize) - 1), 0);\n        },\n        /**\n         * The current offset ( page - 1 ) shown.\n         * Default value: `0`\n         */\n        set: function (val) {\n            this._offset = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isFixedHeader\", {\n        /**\n         * CSS class applied if the header height if fixed height.\n         */\n        get: function () {\n            var headerHeight = this.headerHeight;\n            return typeof headerHeight === 'string' ? headerHeight !== 'auto' : true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isFixedRow\", {\n        /**\n         * CSS class applied to the root element if\n         * the row heights are fixed heights.\n         */\n        get: function () {\n            return this.rowHeight !== 'auto';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isVertScroll\", {\n        /**\n         * CSS class applied to root element if\n         * vertical scrolling is enabled.\n         */\n        get: function () {\n            return this.scrollbarV;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isVirtualized\", {\n        /**\n         * CSS class applied to root element if\n         * virtualization is enabled.\n         */\n        get: function () {\n            return this.virtualization;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isHorScroll\", {\n        /**\n         * CSS class applied to the root element\n         * if the horziontal scrolling is enabled.\n         */\n        get: function () {\n            return this.scrollbarH;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isSelectable\", {\n        /**\n         * CSS class applied to root element is selectable.\n         */\n        get: function () {\n            return this.selectionType !== undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isCheckboxSelection\", {\n        /**\n         * CSS class applied to root is checkbox selection.\n         */\n        get: function () {\n            return this.selectionType === SelectionType.checkbox;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isCellSelection\", {\n        /**\n         * CSS class applied to root if cell selection.\n         */\n        get: function () {\n            return this.selectionType === SelectionType.cell;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isSingleSelection\", {\n        /**\n         * CSS class applied to root if single select.\n         */\n        get: function () {\n            return this.selectionType === SelectionType.single;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isMultiSelection\", {\n        /**\n         * CSS class added to root element if mulit select\n         */\n        get: function () {\n            return this.selectionType === SelectionType.multi;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"isMultiClickSelection\", {\n        /**\n         * CSS class added to root element if mulit click select\n         */\n        get: function () {\n            return this.selectionType === SelectionType.multiClick;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"columnTemplates\", {\n        /**\n         * Returns the column templates.\n         */\n        get: function () {\n            return this._columnTemplates;\n        },\n        /**\n         * Column templates gathered from `ContentChildren`\n         * if described in your markup.\n         */\n        set: function (val) {\n            this._columnTemplates = val;\n            this.translateColumns(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DatatableComponent.prototype, \"allRowsSelected\", {\n        /**\n         * Returns if all rows are selected.\n         */\n        get: function () {\n            var allRowsSelected = this.rows && this.selected && this.selected.length === this.rows.length;\n            if (this.bodyComponent && this.selectAllRowsOnPage) {\n                var indexes = this.bodyComponent.indexes;\n                var rowsOnPage = indexes.last - indexes.first;\n                allRowsSelected = this.selected.length === rowsOnPage;\n            }\n            return this.selected && this.rows && this.rows.length !== 0 && allRowsSelected;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Lifecycle hook that is called after data-bound\n     * properties of a directive are initialized.\n     */\n    DatatableComponent.prototype.ngOnInit = function () {\n        // need to call this immediatly to size\n        // if the table is hidden the visibility\n        // listener will invoke this itself upon show\n        this.recalculate();\n    };\n    /**\n     * Lifecycle hook that is called after a component's\n     * view has been fully initialized.\n     */\n    DatatableComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (!this.externalSorting) {\n            this.sortInternalRows();\n        }\n        // this has to be done to prevent the change detection\n        // tree from freaking out because we are readjusting\n        if (typeof requestAnimationFrame === 'undefined') {\n            return;\n        }\n        requestAnimationFrame(function () {\n            _this.recalculate();\n            // emit page for virtual server-side kickoff\n            if (_this.externalPaging && _this.scrollbarV) {\n                _this.page.emit({\n                    count: _this.count,\n                    pageSize: _this.pageSize,\n                    limit: _this.limit,\n                    offset: 0\n                });\n            }\n        });\n    };\n    /**\n     * Lifecycle hook that is called after a component's\n     * content has been fully initialized.\n     */\n    DatatableComponent.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        this.columnTemplates.changes.subscribe(function (v) { return _this.translateColumns(v); });\n        this.listenForColumnInputChanges();\n    };\n    /**\n     * Translates the templates to the column objects\n     */\n    DatatableComponent.prototype.translateColumns = function (val) {\n        if (val) {\n            var arr = val.toArray();\n            if (arr.length) {\n                this._internalColumns = translateTemplates(arr);\n                setColumnDefaults(this._internalColumns);\n                this.recalculateColumns();\n                this.sortInternalRows();\n                this.cd.markForCheck();\n            }\n        }\n    };\n    /**\n     * Creates a map with the data grouped by the user choice of grouping index\n     *\n     * @param originalArray the original array passed via parameter\n     * @param groupByIndex  the index of the column to group the data by\n     */\n    DatatableComponent.prototype.groupArrayBy = function (originalArray, groupBy) {\n        // create a map to hold groups with their corresponding results\n        var map = new Map();\n        var i = 0;\n        originalArray.forEach(function (item) {\n            var key = item[groupBy];\n            if (!map.has(key)) {\n                map.set(key, [item]);\n            }\n            else {\n                map.get(key).push(item);\n            }\n            i++;\n        });\n        var addGroup = function (key, value) {\n            return { key: key, value: value };\n        };\n        // convert map back to a simple array of objects\n        return Array.from(map, function (x) { return addGroup(x[0], x[1]); });\n    };\n    /*\n     * Lifecycle hook that is called when Angular dirty checks a directive.\n     */\n    DatatableComponent.prototype.ngDoCheck = function () {\n        if (this.rowDiffer.diff(this.rows)) {\n            if (!this.externalSorting) {\n                this.sortInternalRows();\n            }\n            else {\n                this._internalRows = __spread(this.rows);\n            }\n            // auto group by parent on new update\n            this._internalRows = groupRowsByParents(this._internalRows, optionalGetterForProp(this.treeFromRelation), optionalGetterForProp(this.treeToRelation));\n            this.recalculatePages();\n            this.cd.markForCheck();\n        }\n    };\n    /**\n     * Recalc's the sizes of the grid.\n     *\n     * Updated automatically on changes to:\n     *\n     *  - Columns\n     *  - Rows\n     *  - Paging related\n     *\n     * Also can be manually invoked or upon window resize.\n     */\n    DatatableComponent.prototype.recalculate = function () {\n        this.recalculateDims();\n        this.recalculateColumns();\n        this.cd.markForCheck();\n    };\n    /**\n     * Window resize handler to update sizes.\n     */\n    DatatableComponent.prototype.onWindowResize = function () {\n        this.recalculate();\n    };\n    /**\n     * Recalulcates the column widths based on column width\n     * distribution mode and scrollbar offsets.\n     */\n    DatatableComponent.prototype.recalculateColumns = function (columns, forceIdx, allowBleed) {\n        if (columns === void 0) { columns = this._internalColumns; }\n        if (forceIdx === void 0) { forceIdx = -1; }\n        if (allowBleed === void 0) { allowBleed = this.scrollbarH; }\n        if (!columns)\n            return undefined;\n        var width = this._innerWidth;\n        if (this.scrollbarV) {\n            width = width - this.scrollbarHelper.width;\n        }\n        if (this.columnMode === ColumnMode.force) {\n            forceFillColumnWidths(columns, width, forceIdx, allowBleed);\n        }\n        else if (this.columnMode === ColumnMode.flex) {\n            adjustColumnWidths(columns, width);\n        }\n        return columns;\n    };\n    /**\n     * Recalculates the dimensions of the table size.\n     * Internally calls the page size and row count calcs too.\n     *\n     */\n    DatatableComponent.prototype.recalculateDims = function () {\n        var dims = this.dimensionsHelper.getDimensions(this.element);\n        this._innerWidth = Math.floor(dims.width);\n        if (this.scrollbarV) {\n            var height = dims.height;\n            if (this.headerHeight)\n                height = height - this.headerHeight;\n            if (this.footerHeight)\n                height = height - this.footerHeight;\n            this.bodyHeight = height;\n        }\n        this.recalculatePages();\n    };\n    /**\n     * Recalculates the pages after a update.\n     */\n    DatatableComponent.prototype.recalculatePages = function () {\n        this.pageSize = this.calcPageSize();\n        this.rowCount = this.calcRowCount();\n    };\n    /**\n     * Body triggered a page event.\n     */\n    DatatableComponent.prototype.onBodyPage = function (_a) {\n        var offset = _a.offset;\n        // Avoid pagination caming from body events like scroll when the table\n        // has no virtualization and the external paging is enable.\n        // This means, let's the developer handle pagination by my him(her) self\n        if (this.externalPaging && !this.virtualization) {\n            return;\n        }\n        this.offset = offset;\n        this.page.emit({\n            count: this.count,\n            pageSize: this.pageSize,\n            limit: this.limit,\n            offset: this.offset\n        });\n    };\n    /**\n     * The body triggered a scroll event.\n     */\n    DatatableComponent.prototype.onBodyScroll = function (event) {\n        this._offsetX.next(event.offsetX);\n        this.scroll.emit(event);\n        this.cd.detectChanges();\n    };\n    /**\n     * The footer triggered a page event.\n     */\n    DatatableComponent.prototype.onFooterPage = function (event) {\n        this.offset = event.page - 1;\n        this.bodyComponent.updateOffsetY(this.offset);\n        this.page.emit({\n            count: this.count,\n            pageSize: this.pageSize,\n            limit: this.limit,\n            offset: this.offset\n        });\n        if (this.selectAllRowsOnPage) {\n            this.selected = [];\n            this.select.emit({\n                selected: this.selected\n            });\n        }\n    };\n    /**\n     * Recalculates the sizes of the page\n     */\n    DatatableComponent.prototype.calcPageSize = function (val) {\n        if (val === void 0) { val = this.rows; }\n        // Keep the page size constant even if the row has been expanded.\n        // This is because an expanded row is still considered to be a child of\n        // the original row.  Hence calculation would use rowHeight only.\n        if (this.scrollbarV && this.virtualization) {\n            var size = Math.ceil(this.bodyHeight / this.rowHeight);\n            return Math.max(size, 0);\n        }\n        // if limit is passed, we are paging\n        if (this.limit !== undefined) {\n            return this.limit;\n        }\n        // otherwise use row length\n        if (val) {\n            return val.length;\n        }\n        // other empty :(\n        return 0;\n    };\n    /**\n     * Calculates the row count.\n     */\n    DatatableComponent.prototype.calcRowCount = function (val) {\n        if (val === void 0) { val = this.rows; }\n        if (!this.externalPaging) {\n            if (!val)\n                return 0;\n            if (this.groupedRows) {\n                return this.groupedRows.length;\n            }\n            else if (this.treeFromRelation != null && this.treeToRelation != null) {\n                return this._internalRows.length;\n            }\n            else {\n                return val.length;\n            }\n        }\n        return this.count;\n    };\n    /**\n     * The header triggered a contextmenu event.\n     */\n    DatatableComponent.prototype.onColumnContextmenu = function (_a) {\n        var event = _a.event, column = _a.column;\n        this.tableContextmenu.emit({ event: event, type: ContextmenuType.header, content: column });\n    };\n    /**\n     * The body triggered a contextmenu event.\n     */\n    DatatableComponent.prototype.onRowContextmenu = function (_a) {\n        var event = _a.event, row = _a.row;\n        this.tableContextmenu.emit({ event: event, type: ContextmenuType.body, content: row });\n    };\n    /**\n     * The header triggered a column resize event.\n     */\n    DatatableComponent.prototype.onColumnResize = function (_a) {\n        var column = _a.column, newValue = _a.newValue;\n        /* Safari/iOS 10.2 workaround */\n        if (column === undefined) {\n            return;\n        }\n        var idx;\n        var cols = this._internalColumns.map(function (c, i) {\n            c = __assign({}, c);\n            if (c.$$id === column.$$id) {\n                idx = i;\n                c.width = newValue;\n                // set this so we can force the column\n                // width distribution to be to this value\n                c.$$oldWidth = newValue;\n            }\n            return c;\n        });\n        this.recalculateColumns(cols, idx);\n        this._internalColumns = cols;\n        this.resize.emit({\n            column: column,\n            newValue: newValue\n        });\n    };\n    /**\n     * The header triggered a column re-order event.\n     */\n    DatatableComponent.prototype.onColumnReorder = function (_a) {\n        var column = _a.column, newValue = _a.newValue, prevValue = _a.prevValue;\n        var cols = this._internalColumns.map(function (c) {\n            return __assign({}, c);\n        });\n        if (this.swapColumns) {\n            var prevCol = cols[newValue];\n            cols[newValue] = column;\n            cols[prevValue] = prevCol;\n        }\n        else {\n            if (newValue > prevValue) {\n                var movedCol = cols[prevValue];\n                for (var i = prevValue; i < newValue; i++) {\n                    cols[i] = cols[i + 1];\n                }\n                cols[newValue] = movedCol;\n            }\n            else {\n                var movedCol = cols[prevValue];\n                for (var i = prevValue; i > newValue; i--) {\n                    cols[i] = cols[i - 1];\n                }\n                cols[newValue] = movedCol;\n            }\n        }\n        this._internalColumns = cols;\n        this.reorder.emit({\n            column: column,\n            newValue: newValue,\n            prevValue: prevValue\n        });\n    };\n    /**\n     * The header triggered a column sort event.\n     */\n    DatatableComponent.prototype.onColumnSort = function (event) {\n        // clean selected rows\n        if (this.selectAllRowsOnPage) {\n            this.selected = [];\n            this.select.emit({\n                selected: this.selected\n            });\n        }\n        this.sorts = event.sorts;\n        // this could be optimized better since it will resort\n        // the rows again on the 'push' detection...\n        if (this.externalSorting === false) {\n            // don't use normal setter so we don't resort\n            this.sortInternalRows();\n        }\n        // auto group by parent on new update\n        this._internalRows = groupRowsByParents(this._internalRows, optionalGetterForProp(this.treeFromRelation), optionalGetterForProp(this.treeToRelation));\n        // Always go to first page when sorting to see the newly sorted data\n        this.offset = 0;\n        this.bodyComponent.updateOffsetY(this.offset);\n        this.sort.emit(event);\n    };\n    /**\n     * Toggle all row selection\n     */\n    DatatableComponent.prototype.onHeaderSelect = function (event) {\n        var _a, _b;\n        if (this.bodyComponent && this.selectAllRowsOnPage) {\n            // before we splice, chk if we currently have all selected\n            var first = this.bodyComponent.indexes.first;\n            var last = this.bodyComponent.indexes.last;\n            var allSelected = this.selected.length === last - first;\n            // remove all existing either way\n            this.selected = [];\n            // do the opposite here\n            if (!allSelected) {\n                (_a = this.selected).push.apply(_a, __spread(this._internalRows.slice(first, last)));\n            }\n        }\n        else {\n            // before we splice, chk if we currently have all selected\n            var allSelected = this.selected.length === this.rows.length;\n            // remove all existing either way\n            this.selected = [];\n            // do the opposite here\n            if (!allSelected) {\n                (_b = this.selected).push.apply(_b, __spread(this.rows));\n            }\n        }\n        this.select.emit({\n            selected: this.selected\n        });\n    };\n    /**\n     * A row was selected from body\n     */\n    DatatableComponent.prototype.onBodySelect = function (event) {\n        this.select.emit(event);\n    };\n    /**\n     * A row was expanded or collapsed for tree\n     */\n    DatatableComponent.prototype.onTreeAction = function (event) {\n        var _this = this;\n        var row = event.row;\n        // TODO: For duplicated items this will not work\n        var rowIndex = this._rows.findIndex(function (r) { return r[_this.treeToRelation] === event.row[_this.treeToRelation]; });\n        this.treeAction.emit({ row: row, rowIndex: rowIndex });\n    };\n    DatatableComponent.prototype.ngOnDestroy = function () {\n        this._subscriptions.forEach(function (subscription) { return subscription.unsubscribe(); });\n    };\n    /**\n     * listen for changes to input bindings of all DataTableColumnDirective and\n     * trigger the columnTemplates.changes observable to emit\n     */\n    DatatableComponent.prototype.listenForColumnInputChanges = function () {\n        var _this = this;\n        this._subscriptions.push(this.columnChangesService.columnInputChanges$.subscribe(function () {\n            if (_this.columnTemplates) {\n                _this.columnTemplates.notifyOnChanges();\n            }\n        }));\n    };\n    DatatableComponent.prototype.sortInternalRows = function () {\n        this._internalRows = sortRows(this._internalRows, this._internalColumns, this.sorts);\n    };\n    DatatableComponent.ctorParameters = function () { return [\n        { type: ScrollbarHelper, decorators: [{ type: SkipSelf }] },\n        { type: DimensionsHelper, decorators: [{ type: SkipSelf }] },\n        { type: ChangeDetectorRef },\n        { type: ElementRef },\n        { type: KeyValueDiffers },\n        { type: ColumnChangesService },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: ['configuration',] }] }\n    ]; };\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"targetMarkerTemplate\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"rows\", null);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"groupRowsBy\", null);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"groupedRows\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"columns\", null);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"selected\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"scrollbarV\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"scrollbarH\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"rowHeight\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"columnMode\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"headerHeight\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"footerHeight\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"externalPaging\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"externalSorting\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"limit\", null);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"count\", null);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"offset\", null);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"loadingIndicator\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"selectionType\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"reorderable\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"swapColumns\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"sortType\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"sorts\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"cssClasses\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"messages\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"rowClass\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"selectCheck\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"displayCheck\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"groupExpansionDefault\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"trackByProp\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"selectAllRowsOnPage\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"virtualization\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"treeFromRelation\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"treeToRelation\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"summaryRow\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"summaryHeight\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"summaryPosition\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"scroll\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"activate\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"select\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"sort\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"page\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"reorder\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"resize\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"tableContextmenu\", void 0);\n    __decorate([\n        Output()\n    ], DatatableComponent.prototype, \"treeAction\", void 0);\n    __decorate([\n        HostBinding('class.fixed-header')\n    ], DatatableComponent.prototype, \"isFixedHeader\", null);\n    __decorate([\n        HostBinding('class.fixed-row')\n    ], DatatableComponent.prototype, \"isFixedRow\", null);\n    __decorate([\n        HostBinding('class.scroll-vertical')\n    ], DatatableComponent.prototype, \"isVertScroll\", null);\n    __decorate([\n        HostBinding('class.virtualized')\n    ], DatatableComponent.prototype, \"isVirtualized\", null);\n    __decorate([\n        HostBinding('class.scroll-horz')\n    ], DatatableComponent.prototype, \"isHorScroll\", null);\n    __decorate([\n        HostBinding('class.selectable')\n    ], DatatableComponent.prototype, \"isSelectable\", null);\n    __decorate([\n        HostBinding('class.checkbox-selection')\n    ], DatatableComponent.prototype, \"isCheckboxSelection\", null);\n    __decorate([\n        HostBinding('class.cell-selection')\n    ], DatatableComponent.prototype, \"isCellSelection\", null);\n    __decorate([\n        HostBinding('class.single-selection')\n    ], DatatableComponent.prototype, \"isSingleSelection\", null);\n    __decorate([\n        HostBinding('class.multi-selection')\n    ], DatatableComponent.prototype, \"isMultiSelection\", null);\n    __decorate([\n        HostBinding('class.multi-click-selection')\n    ], DatatableComponent.prototype, \"isMultiClickSelection\", null);\n    __decorate([\n        ContentChildren(DataTableColumnDirective)\n    ], DatatableComponent.prototype, \"columnTemplates\", null);\n    __decorate([\n        ContentChild(DatatableRowDetailDirective)\n    ], DatatableComponent.prototype, \"rowDetail\", void 0);\n    __decorate([\n        ContentChild(DatatableGroupHeaderDirective)\n    ], DatatableComponent.prototype, \"groupHeader\", void 0);\n    __decorate([\n        ContentChild(DatatableFooterDirective)\n    ], DatatableComponent.prototype, \"footer\", void 0);\n    __decorate([\n        ViewChild(DataTableBodyComponent)\n    ], DatatableComponent.prototype, \"bodyComponent\", void 0);\n    __decorate([\n        ViewChild(DataTableHeaderComponent)\n    ], DatatableComponent.prototype, \"headerComponent\", void 0);\n    __decorate([\n        Input()\n    ], DatatableComponent.prototype, \"rowIdentity\", void 0);\n    __decorate([\n        HostListener('window:resize'),\n        throttleable(5)\n    ], DatatableComponent.prototype, \"onWindowResize\", null);\n    DatatableComponent = __decorate([\n        Component({\n            selector: 'ngx-datatable',\n            template: \"<div visibilityObserver (visible)=\\\"recalculate()\\\">\\n  <datatable-header\\n    *ngIf=\\\"headerHeight\\\"\\n    [sorts]=\\\"sorts\\\"\\n    [sortType]=\\\"sortType\\\"\\n    [scrollbarH]=\\\"scrollbarH\\\"\\n    [innerWidth]=\\\"_innerWidth\\\"\\n    [offsetX]=\\\"_offsetX | async\\\"\\n    [dealsWithGroup]=\\\"groupedRows !== undefined\\\"\\n    [columns]=\\\"_internalColumns\\\"\\n    [headerHeight]=\\\"headerHeight\\\"\\n    [reorderable]=\\\"reorderable\\\"\\n    [targetMarkerTemplate]=\\\"targetMarkerTemplate\\\"\\n    [sortAscendingIcon]=\\\"cssClasses.sortAscending\\\"\\n    [sortDescendingIcon]=\\\"cssClasses.sortDescending\\\"\\n    [sortUnsetIcon]=\\\"cssClasses.sortUnset\\\"\\n    [allRowsSelected]=\\\"allRowsSelected\\\"\\n    [selectionType]=\\\"selectionType\\\"\\n    (sort)=\\\"onColumnSort($event)\\\"\\n    (resize)=\\\"onColumnResize($event)\\\"\\n    (reorder)=\\\"onColumnReorder($event)\\\"\\n    (select)=\\\"onHeaderSelect($event)\\\"\\n    (columnContextmenu)=\\\"onColumnContextmenu($event)\\\"\\n  >\\n  </datatable-header>\\n  <datatable-body\\n    [groupRowsBy]=\\\"groupRowsBy\\\"\\n    [groupedRows]=\\\"groupedRows\\\"\\n    [rows]=\\\"_internalRows\\\"\\n    [groupExpansionDefault]=\\\"groupExpansionDefault\\\"\\n    [scrollbarV]=\\\"scrollbarV\\\"\\n    [scrollbarH]=\\\"scrollbarH\\\"\\n    [virtualization]=\\\"virtualization\\\"\\n    [loadingIndicator]=\\\"loadingIndicator\\\"\\n    [externalPaging]=\\\"externalPaging\\\"\\n    [rowHeight]=\\\"rowHeight\\\"\\n    [rowCount]=\\\"rowCount\\\"\\n    [offset]=\\\"offset\\\"\\n    [trackByProp]=\\\"trackByProp\\\"\\n    [columns]=\\\"_internalColumns\\\"\\n    [pageSize]=\\\"pageSize\\\"\\n    [offsetX]=\\\"_offsetX | async\\\"\\n    [rowDetail]=\\\"rowDetail\\\"\\n    [groupHeader]=\\\"groupHeader\\\"\\n    [selected]=\\\"selected\\\"\\n    [innerWidth]=\\\"_innerWidth\\\"\\n    [bodyHeight]=\\\"bodyHeight\\\"\\n    [selectionType]=\\\"selectionType\\\"\\n    [emptyMessage]=\\\"messages.emptyMessage\\\"\\n    [rowIdentity]=\\\"rowIdentity\\\"\\n    [rowClass]=\\\"rowClass\\\"\\n    [selectCheck]=\\\"selectCheck\\\"\\n    [displayCheck]=\\\"displayCheck\\\"\\n    [summaryRow]=\\\"summaryRow\\\"\\n    [summaryHeight]=\\\"summaryHeight\\\"\\n    [summaryPosition]=\\\"summaryPosition\\\"\\n    (page)=\\\"onBodyPage($event)\\\"\\n    (activate)=\\\"activate.emit($event)\\\"\\n    (rowContextmenu)=\\\"onRowContextmenu($event)\\\"\\n    (select)=\\\"onBodySelect($event)\\\"\\n    (scroll)=\\\"onBodyScroll($event)\\\"\\n    (treeAction)=\\\"onTreeAction($event)\\\"\\n  >\\n  </datatable-body>\\n  <datatable-footer\\n    *ngIf=\\\"footerHeight\\\"\\n    [rowCount]=\\\"rowCount\\\"\\n    [pageSize]=\\\"pageSize\\\"\\n    [offset]=\\\"offset\\\"\\n    [footerHeight]=\\\"footerHeight\\\"\\n    [footerTemplate]=\\\"footer\\\"\\n    [totalMessage]=\\\"messages.totalMessage\\\"\\n    [pagerLeftArrowIcon]=\\\"cssClasses.pagerLeftArrow\\\"\\n    [pagerRightArrowIcon]=\\\"cssClasses.pagerRightArrow\\\"\\n    [pagerPreviousIcon]=\\\"cssClasses.pagerPrevious\\\"\\n    [selectedCount]=\\\"selected.length\\\"\\n    [selectedMessage]=\\\"!!selectionType && messages.selectedMessage\\\"\\n    [pagerNextIcon]=\\\"cssClasses.pagerNext\\\"\\n    (page)=\\\"onFooterPage($event)\\\"\\n  >\\n  </datatable-footer>\\n</div>\\n\",\n            changeDetection: ChangeDetectionStrategy.OnPush,\n            encapsulation: ViewEncapsulation.None,\n            host: {\n                class: 'ngx-datatable'\n            },\n            styles: [\".ngx-datatable{display:block;overflow:hidden;justify-content:center;position:relative;transform:translate3d(0,0,0)}.ngx-datatable [hidden]{display:none!important}.ngx-datatable *,.ngx-datatable :after,.ngx-datatable :before{box-sizing:border-box}.ngx-datatable.scroll-vertical .datatable-body{overflow-y:auto}.ngx-datatable.scroll-vertical.virtualized .datatable-body .datatable-row-wrapper{position:absolute}.ngx-datatable.scroll-horz .datatable-body{overflow-x:auto;-webkit-overflow-scrolling:touch}.ngx-datatable.fixed-header .datatable-header .datatable-header-inner{white-space:nowrap}.ngx-datatable.fixed-header .datatable-header .datatable-header-inner .datatable-header-cell{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ngx-datatable.fixed-row .datatable-scroll,.ngx-datatable.fixed-row .datatable-scroll .datatable-body-row{white-space:nowrap}.ngx-datatable.fixed-row .datatable-scroll .datatable-body-row .datatable-body-cell,.ngx-datatable.fixed-row .datatable-scroll .datatable-body-row .datatable-body-group-cell{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.ngx-datatable .datatable-body-row,.ngx-datatable .datatable-header-inner,.ngx-datatable .datatable-row-center{display:flex;flex-direction:row;-o-flex-flow:row;flex-flow:row}.ngx-datatable .datatable-body-cell,.ngx-datatable .datatable-header-cell{overflow-x:hidden;vertical-align:top;display:inline-block;line-height:1.625}.ngx-datatable .datatable-body-cell:focus,.ngx-datatable .datatable-header-cell:focus{outline:0}.ngx-datatable .datatable-row-left,.ngx-datatable .datatable-row-right{z-index:9}.ngx-datatable .datatable-row-center,.ngx-datatable .datatable-row-group,.ngx-datatable .datatable-row-left,.ngx-datatable .datatable-row-right{position:relative}.ngx-datatable .datatable-header{display:block;overflow:hidden}.ngx-datatable .datatable-header .datatable-header-inner{align-items:stretch;-webkit-align-items:stretch}.ngx-datatable .datatable-header .datatable-header-cell{position:relative;display:inline-block}.ngx-datatable .datatable-header .datatable-header-cell.sortable .datatable-header-cell-wrapper{cursor:pointer}.ngx-datatable .datatable-header .datatable-header-cell.longpress .datatable-header-cell-wrapper{cursor:move}.ngx-datatable .datatable-header .datatable-header-cell .sort-btn{line-height:100%;vertical-align:middle;display:inline-block;cursor:pointer}.ngx-datatable .datatable-header .datatable-header-cell .resize-handle,.ngx-datatable .datatable-header .datatable-header-cell .resize-handle--not-resizable{display:inline-block;position:absolute;right:0;top:0;bottom:0;width:5px;padding:0 4px;visibility:hidden}.ngx-datatable .datatable-header .datatable-header-cell .resize-handle{cursor:ew-resize}.ngx-datatable .datatable-header .datatable-header-cell.resizeable:hover .resize-handle,.ngx-datatable .datatable-header .datatable-header-cell:hover .resize-handle--not-resizable{visibility:visible}.ngx-datatable .datatable-header .datatable-header-cell .targetMarker{position:absolute;top:0;bottom:0}.ngx-datatable .datatable-header .datatable-header-cell .targetMarker.dragFromLeft{right:0}.ngx-datatable .datatable-header .datatable-header-cell .targetMarker.dragFromRight{left:0}.ngx-datatable .datatable-header .datatable-header-cell .datatable-header-cell-template-wrap{height:inherit}.ngx-datatable .datatable-body{position:relative;z-index:10;display:block}.ngx-datatable .datatable-body .datatable-scroll{display:inline-block}.ngx-datatable .datatable-body .datatable-row-detail{overflow-y:hidden}.ngx-datatable .datatable-body .datatable-row-wrapper{display:flex;flex-direction:column}.ngx-datatable .datatable-body .datatable-body-row{outline:0}.ngx-datatable .datatable-body .datatable-body-row>div{display:flex}.ngx-datatable .datatable-footer{display:block;width:100%;overflow:auto}.ngx-datatable .datatable-footer .datatable-footer-inner{display:flex;align-items:center;width:100%}.ngx-datatable .datatable-footer .selected-count .page-count{flex:1 1 40%}.ngx-datatable .datatable-footer .selected-count .datatable-pager{flex:1 1 60%}.ngx-datatable .datatable-footer .page-count{flex:1 1 20%}.ngx-datatable .datatable-footer .datatable-pager{flex:1 1 80%;text-align:right}.ngx-datatable .datatable-footer .datatable-pager .pager,.ngx-datatable .datatable-footer .datatable-pager .pager li{padding:0;margin:0;display:inline-block;list-style:none}.ngx-datatable .datatable-footer .datatable-pager .pager li,.ngx-datatable .datatable-footer .datatable-pager .pager li a{outline:0}.ngx-datatable .datatable-footer .datatable-pager .pager li a{cursor:pointer;display:inline-block}.ngx-datatable .datatable-footer .datatable-pager .pager li.disabled a{cursor:not-allowed}\"]\n        }),\n        __param(0, SkipSelf()),\n        __param(1, SkipSelf()),\n        __param(6, Optional()), __param(6, Inject('configuration'))\n    ], DatatableComponent);\n    return DatatableComponent;\n}());\n\nvar DataTableHeaderCellComponent = /** @class */ (function () {\n    function DataTableHeaderCellComponent(cd) {\n        this.cd = cd;\n        this.sort = new EventEmitter();\n        this.select = new EventEmitter();\n        this.columnContextmenu = new EventEmitter(false);\n        this.sortFn = this.onSort.bind(this);\n        this.selectFn = this.select.emit.bind(this.select);\n        this.cellContext = {\n            column: this.column,\n            sortDir: this.sortDir,\n            sortFn: this.sortFn,\n            allRowsSelected: this.allRowsSelected,\n            selectFn: this.selectFn\n        };\n    }\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"allRowsSelected\", {\n        get: function () {\n            return this._allRowsSelected;\n        },\n        set: function (value) {\n            this._allRowsSelected = value;\n            this.cellContext.allRowsSelected = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"column\", {\n        get: function () {\n            return this._column;\n        },\n        set: function (column) {\n            this._column = column;\n            this.cellContext.column = column;\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"sorts\", {\n        get: function () {\n            return this._sorts;\n        },\n        set: function (val) {\n            this._sorts = val;\n            this.sortDir = this.calcSortDir(val);\n            this.cellContext.sortDir = this.sortDir;\n            this.sortClass = this.calcSortClass(this.sortDir);\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"columnCssClasses\", {\n        get: function () {\n            var e_1, _a;\n            var cls = 'datatable-header-cell';\n            if (this.column.sortable)\n                cls += ' sortable';\n            if (this.column.resizeable)\n                cls += ' resizeable';\n            if (this.column.headerClass) {\n                if (typeof this.column.headerClass === 'string') {\n                    cls += ' ' + this.column.headerClass;\n                }\n                else if (typeof this.column.headerClass === 'function') {\n                    var res = this.column.headerClass({\n                        column: this.column\n                    });\n                    if (typeof res === 'string') {\n                        cls += res;\n                    }\n                    else if (typeof res === 'object') {\n                        var keys = Object.keys(res);\n                        try {\n                            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                                var k = keys_1_1.value;\n                                if (res[k] === true)\n                                    cls += \" \" + k;\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                    }\n                }\n            }\n            var sortDir = this.sortDir;\n            if (sortDir) {\n                cls += \" sort-active sort-\" + sortDir;\n            }\n            return cls;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"name\", {\n        get: function () {\n            // guaranteed to have a value by setColumnDefaults() in column-helper.ts\n            return this.column.headerTemplate === undefined ? this.column.name : undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"minWidth\", {\n        get: function () {\n            return this.column.minWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"maxWidth\", {\n        get: function () {\n            return this.column.maxWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"width\", {\n        get: function () {\n            return this.column.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableHeaderCellComponent.prototype, \"isCheckboxable\", {\n        get: function () {\n            return this.column.checkboxable && this.column.headerCheckboxable && this.selectionType === SelectionType.checkbox;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTableHeaderCellComponent.prototype.onContextmenu = function ($event) {\n        this.columnContextmenu.emit({ event: $event, column: this.column });\n    };\n    DataTableHeaderCellComponent.prototype.ngOnInit = function () {\n        this.sortClass = this.calcSortClass(this.sortDir);\n    };\n    DataTableHeaderCellComponent.prototype.calcSortDir = function (sorts) {\n        var _this = this;\n        if (sorts && this.column) {\n            var sort = sorts.find(function (s) {\n                return s.prop === _this.column.prop;\n            });\n            if (sort)\n                return sort.dir;\n        }\n    };\n    DataTableHeaderCellComponent.prototype.onSort = function () {\n        if (!this.column.sortable)\n            return;\n        var newValue = nextSortDir(this.sortType, this.sortDir);\n        this.sort.emit({\n            column: this.column,\n            prevValue: this.sortDir,\n            newValue: newValue\n        });\n    };\n    DataTableHeaderCellComponent.prototype.calcSortClass = function (sortDir) {\n        if (!this.cellContext.column.sortable)\n            return;\n        if (sortDir === SortDirection.asc) {\n            return \"sort-btn sort-asc \" + this.sortAscendingIcon;\n        }\n        else if (sortDir === SortDirection.desc) {\n            return \"sort-btn sort-desc \" + this.sortDescendingIcon;\n        }\n        else {\n            return \"sort-btn \" + this.sortUnsetIcon;\n        }\n    };\n    DataTableHeaderCellComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef }\n    ]; };\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"sortType\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"sortAscendingIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"sortDescendingIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"sortUnsetIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"isTarget\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"targetMarkerTemplate\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"targetMarkerContext\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"allRowsSelected\", null);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"selectionType\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"column\", null);\n    __decorate([\n        HostBinding('style.height.px'),\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"headerHeight\", void 0);\n    __decorate([\n        Input()\n    ], DataTableHeaderCellComponent.prototype, \"sorts\", null);\n    __decorate([\n        Output()\n    ], DataTableHeaderCellComponent.prototype, \"sort\", void 0);\n    __decorate([\n        Output()\n    ], DataTableHeaderCellComponent.prototype, \"select\", void 0);\n    __decorate([\n        Output()\n    ], DataTableHeaderCellComponent.prototype, \"columnContextmenu\", void 0);\n    __decorate([\n        HostBinding('class')\n    ], DataTableHeaderCellComponent.prototype, \"columnCssClasses\", null);\n    __decorate([\n        HostBinding('attr.title')\n    ], DataTableHeaderCellComponent.prototype, \"name\", null);\n    __decorate([\n        HostBinding('style.minWidth.px')\n    ], DataTableHeaderCellComponent.prototype, \"minWidth\", null);\n    __decorate([\n        HostBinding('style.maxWidth.px')\n    ], DataTableHeaderCellComponent.prototype, \"maxWidth\", null);\n    __decorate([\n        HostBinding('style.width.px')\n    ], DataTableHeaderCellComponent.prototype, \"width\", null);\n    __decorate([\n        HostListener('contextmenu', ['$event'])\n    ], DataTableHeaderCellComponent.prototype, \"onContextmenu\", null);\n    DataTableHeaderCellComponent = __decorate([\n        Component({\n            selector: 'datatable-header-cell',\n            template: \"\\n    <div class=\\\"datatable-header-cell-template-wrap\\\">\\n      <ng-template\\n        *ngIf=\\\"isTarget\\\"\\n        [ngTemplateOutlet]=\\\"targetMarkerTemplate\\\"\\n        [ngTemplateOutletContext]=\\\"targetMarkerContext\\\"\\n      >\\n      </ng-template>\\n      <label *ngIf=\\\"isCheckboxable\\\" class=\\\"datatable-checkbox\\\">\\n        <input type=\\\"checkbox\\\" [checked]=\\\"allRowsSelected\\\" (change)=\\\"select.emit(!allRowsSelected)\\\" />\\n      </label>\\n      <span *ngIf=\\\"!column.headerTemplate\\\" class=\\\"datatable-header-cell-wrapper\\\">\\n        <span class=\\\"datatable-header-cell-label draggable\\\" (click)=\\\"onSort()\\\" [innerHTML]=\\\"name\\\"> </span>\\n      </span>\\n      <ng-template\\n        *ngIf=\\\"column.headerTemplate\\\"\\n        [ngTemplateOutlet]=\\\"column.headerTemplate\\\"\\n        [ngTemplateOutletContext]=\\\"cellContext\\\"\\n      >\\n      </ng-template>\\n      <span (click)=\\\"onSort()\\\" [class]=\\\"sortClass\\\"> </span>\\n    </div>\\n  \",\n            host: {\n                class: 'datatable-header-cell'\n            },\n            changeDetection: ChangeDetectionStrategy.OnPush\n        })\n    ], DataTableHeaderCellComponent);\n    return DataTableHeaderCellComponent;\n}());\n\nvar DataTableFooterComponent = /** @class */ (function () {\n    function DataTableFooterComponent() {\n        this.selectedCount = 0;\n        this.page = new EventEmitter();\n    }\n    Object.defineProperty(DataTableFooterComponent.prototype, \"isVisible\", {\n        get: function () {\n            return this.rowCount / this.pageSize > 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableFooterComponent.prototype, \"curPage\", {\n        get: function () {\n            return this.offset + 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"footerHeight\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"rowCount\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"pageSize\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"offset\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"pagerLeftArrowIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"pagerRightArrowIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"pagerPreviousIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"pagerNextIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"totalMessage\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"footerTemplate\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"selectedCount\", void 0);\n    __decorate([\n        Input()\n    ], DataTableFooterComponent.prototype, \"selectedMessage\", void 0);\n    __decorate([\n        Output()\n    ], DataTableFooterComponent.prototype, \"page\", void 0);\n    DataTableFooterComponent = __decorate([\n        Component({\n            selector: 'datatable-footer',\n            template: \"\\n    <div\\n      class=\\\"datatable-footer-inner\\\"\\n      [ngClass]=\\\"{ 'selected-count': selectedMessage }\\\"\\n      [style.height.px]=\\\"footerHeight\\\"\\n    >\\n      <ng-template\\n        *ngIf=\\\"footerTemplate\\\"\\n        [ngTemplateOutlet]=\\\"footerTemplate.template\\\"\\n        [ngTemplateOutletContext]=\\\"{\\n          rowCount: rowCount,\\n          pageSize: pageSize,\\n          selectedCount: selectedCount,\\n          curPage: curPage,\\n          offset: offset\\n        }\\\"\\n      >\\n      </ng-template>\\n      <div class=\\\"page-count\\\" *ngIf=\\\"!footerTemplate\\\">\\n        <span *ngIf=\\\"selectedMessage\\\"> {{ selectedCount?.toLocaleString() }} {{ selectedMessage }} / </span>\\n        {{ rowCount?.toLocaleString() }} {{ totalMessage }}\\n      </div>\\n      <datatable-pager\\n        *ngIf=\\\"!footerTemplate\\\"\\n        [pagerLeftArrowIcon]=\\\"pagerLeftArrowIcon\\\"\\n        [pagerRightArrowIcon]=\\\"pagerRightArrowIcon\\\"\\n        [pagerPreviousIcon]=\\\"pagerPreviousIcon\\\"\\n        [pagerNextIcon]=\\\"pagerNextIcon\\\"\\n        [page]=\\\"curPage\\\"\\n        [size]=\\\"pageSize\\\"\\n        [count]=\\\"rowCount\\\"\\n        [hidden]=\\\"!isVisible\\\"\\n        (change)=\\\"page.emit($event)\\\"\\n      >\\n      </datatable-pager>\\n    </div>\\n  \",\n            host: {\n                class: 'datatable-footer'\n            },\n            changeDetection: ChangeDetectionStrategy.OnPush\n        })\n    ], DataTableFooterComponent);\n    return DataTableFooterComponent;\n}());\n\nvar DataTablePagerComponent = /** @class */ (function () {\n    function DataTablePagerComponent() {\n        this.change = new EventEmitter();\n        this._count = 0;\n        this._page = 1;\n        this._size = 0;\n    }\n    Object.defineProperty(DataTablePagerComponent.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        set: function (val) {\n            this._size = val;\n            this.pages = this.calcPages();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTablePagerComponent.prototype, \"count\", {\n        get: function () {\n            return this._count;\n        },\n        set: function (val) {\n            this._count = val;\n            this.pages = this.calcPages();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTablePagerComponent.prototype, \"page\", {\n        get: function () {\n            return this._page;\n        },\n        set: function (val) {\n            this._page = val;\n            this.pages = this.calcPages();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTablePagerComponent.prototype, \"totalPages\", {\n        get: function () {\n            var count = this.size < 1 ? 1 : Math.ceil(this.count / this.size);\n            return Math.max(count || 0, 1);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTablePagerComponent.prototype.canPrevious = function () {\n        return this.page > 1;\n    };\n    DataTablePagerComponent.prototype.canNext = function () {\n        return this.page < this.totalPages;\n    };\n    DataTablePagerComponent.prototype.prevPage = function () {\n        this.selectPage(this.page - 1);\n    };\n    DataTablePagerComponent.prototype.nextPage = function () {\n        this.selectPage(this.page + 1);\n    };\n    DataTablePagerComponent.prototype.selectPage = function (page) {\n        if (page > 0 && page <= this.totalPages && page !== this.page) {\n            this.page = page;\n            this.change.emit({\n                page: page\n            });\n        }\n    };\n    DataTablePagerComponent.prototype.calcPages = function (page) {\n        var pages = [];\n        var startPage = 1;\n        var endPage = this.totalPages;\n        var maxSize = 5;\n        var isMaxSized = maxSize < this.totalPages;\n        page = page || this.page;\n        if (isMaxSized) {\n            startPage = page - Math.floor(maxSize / 2);\n            endPage = page + Math.floor(maxSize / 2);\n            if (startPage < 1) {\n                startPage = 1;\n                endPage = Math.min(startPage + maxSize - 1, this.totalPages);\n            }\n            else if (endPage > this.totalPages) {\n                startPage = Math.max(this.totalPages - maxSize + 1, 1);\n                endPage = this.totalPages;\n            }\n        }\n        for (var num = startPage; num <= endPage; num++) {\n            pages.push({\n                number: num,\n                text: num\n            });\n        }\n        return pages;\n    };\n    __decorate([\n        Input()\n    ], DataTablePagerComponent.prototype, \"pagerLeftArrowIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTablePagerComponent.prototype, \"pagerRightArrowIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTablePagerComponent.prototype, \"pagerPreviousIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTablePagerComponent.prototype, \"pagerNextIcon\", void 0);\n    __decorate([\n        Input()\n    ], DataTablePagerComponent.prototype, \"size\", null);\n    __decorate([\n        Input()\n    ], DataTablePagerComponent.prototype, \"count\", null);\n    __decorate([\n        Input()\n    ], DataTablePagerComponent.prototype, \"page\", null);\n    __decorate([\n        Output()\n    ], DataTablePagerComponent.prototype, \"change\", void 0);\n    DataTablePagerComponent = __decorate([\n        Component({\n            selector: 'datatable-pager',\n            template: \"\\n    <ul class=\\\"pager\\\">\\n      <li [class.disabled]=\\\"!canPrevious()\\\">\\n        <a role=\\\"button\\\" aria-label=\\\"go to first page\\\" href=\\\"javascript:void(0)\\\" (click)=\\\"selectPage(1)\\\">\\n          <i class=\\\"{{ pagerPreviousIcon }}\\\"></i>\\n        </a>\\n      </li>\\n      <li [class.disabled]=\\\"!canPrevious()\\\">\\n        <a role=\\\"button\\\" aria-label=\\\"go to previous page\\\" href=\\\"javascript:void(0)\\\" (click)=\\\"prevPage()\\\">\\n          <i class=\\\"{{ pagerLeftArrowIcon }}\\\"></i>\\n        </a>\\n      </li>\\n      <li\\n        role=\\\"button\\\"\\n        [attr.aria-label]=\\\"'page ' + pg.number\\\"\\n        class=\\\"pages\\\"\\n        *ngFor=\\\"let pg of pages\\\"\\n        [class.active]=\\\"pg.number === page\\\"\\n      >\\n        <a href=\\\"javascript:void(0)\\\" (click)=\\\"selectPage(pg.number)\\\">\\n          {{ pg.text }}\\n        </a>\\n      </li>\\n      <li [class.disabled]=\\\"!canNext()\\\">\\n        <a role=\\\"button\\\" aria-label=\\\"go to next page\\\" href=\\\"javascript:void(0)\\\" (click)=\\\"nextPage()\\\">\\n          <i class=\\\"{{ pagerRightArrowIcon }}\\\"></i>\\n        </a>\\n      </li>\\n      <li [class.disabled]=\\\"!canNext()\\\">\\n        <a role=\\\"button\\\" aria-label=\\\"go to last page\\\" href=\\\"javascript:void(0)\\\" (click)=\\\"selectPage(totalPages)\\\">\\n          <i class=\\\"{{ pagerNextIcon }}\\\"></i>\\n        </a>\\n      </li>\\n    </ul>\\n  \",\n            host: {\n                class: 'datatable-pager'\n            },\n            changeDetection: ChangeDetectionStrategy.OnPush\n        })\n    ], DataTablePagerComponent);\n    return DataTablePagerComponent;\n}());\n\nvar ProgressBarComponent = /** @class */ (function () {\n    function ProgressBarComponent() {\n    }\n    ProgressBarComponent = __decorate([\n        Component({\n            selector: 'datatable-progress',\n            template: \"\\n    <div class=\\\"progress-linear\\\" role=\\\"progressbar\\\">\\n      <div class=\\\"container\\\">\\n        <div class=\\\"bar\\\"></div>\\n      </div>\\n    </div>\\n  \",\n            changeDetection: ChangeDetectionStrategy.OnPush\n        })\n    ], ProgressBarComponent);\n    return ProgressBarComponent;\n}());\n\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"up\"] = 38] = \"up\";\n    Keys[Keys[\"down\"] = 40] = \"down\";\n    Keys[Keys[\"return\"] = 13] = \"return\";\n    Keys[Keys[\"escape\"] = 27] = \"escape\";\n    Keys[Keys[\"left\"] = 37] = \"left\";\n    Keys[Keys[\"right\"] = 39] = \"right\";\n})(Keys || (Keys = {}));\n\nvar DataTableBodyRowComponent = /** @class */ (function () {\n    function DataTableBodyRowComponent(differs, scrollbarHelper, cd, element) {\n        this.differs = differs;\n        this.scrollbarHelper = scrollbarHelper;\n        this.cd = cd;\n        this.treeStatus = 'collapsed';\n        this.activate = new EventEmitter();\n        this.treeAction = new EventEmitter();\n        this._groupStyles = {\n            left: {},\n            center: {},\n            right: {}\n        };\n        this._element = element.nativeElement;\n        this._rowDiffer = differs.find({}).create();\n    }\n    Object.defineProperty(DataTableBodyRowComponent.prototype, \"columns\", {\n        get: function () {\n            return this._columns;\n        },\n        set: function (val) {\n            this._columns = val;\n            this.recalculateColumns(val);\n            this.buildStylesByGroup();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyRowComponent.prototype, \"innerWidth\", {\n        get: function () {\n            return this._innerWidth;\n        },\n        set: function (val) {\n            if (this._columns) {\n                var colByPin = columnsByPin(this._columns);\n                this._columnGroupWidths = columnGroupWidths(colByPin, this._columns);\n            }\n            this._innerWidth = val;\n            this.recalculateColumns();\n            this.buildStylesByGroup();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyRowComponent.prototype, \"offsetX\", {\n        get: function () {\n            return this._offsetX;\n        },\n        set: function (val) {\n            this._offsetX = val;\n            this.buildStylesByGroup();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyRowComponent.prototype, \"cssClass\", {\n        get: function () {\n            var e_1, _a;\n            var cls = 'datatable-body-row';\n            if (this.isSelected) {\n                cls += ' active';\n            }\n            if (this.rowIndex % 2 !== 0) {\n                cls += ' datatable-row-odd';\n            }\n            if (this.rowIndex % 2 === 0) {\n                cls += ' datatable-row-even';\n            }\n            if (this.rowClass) {\n                var res = this.rowClass(this.row);\n                if (typeof res === 'string') {\n                    cls += \" \" + res;\n                }\n                else if (typeof res === 'object') {\n                    var keys = Object.keys(res);\n                    try {\n                        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                            var k = keys_1_1.value;\n                            if (res[k] === true) {\n                                cls += \" \" + k;\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n            }\n            return cls;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyRowComponent.prototype, \"columnsTotalWidths\", {\n        get: function () {\n            return this._columnGroupWidths.total;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTableBodyRowComponent.prototype.ngDoCheck = function () {\n        if (this._rowDiffer.diff(this.row)) {\n            this.cd.markForCheck();\n        }\n    };\n    DataTableBodyRowComponent.prototype.trackByGroups = function (index, colGroup) {\n        return colGroup.type;\n    };\n    DataTableBodyRowComponent.prototype.columnTrackingFn = function (index, column) {\n        return column.$$id;\n    };\n    DataTableBodyRowComponent.prototype.buildStylesByGroup = function () {\n        this._groupStyles.left = this.calcStylesByGroup('left');\n        this._groupStyles.center = this.calcStylesByGroup('center');\n        this._groupStyles.right = this.calcStylesByGroup('right');\n        this.cd.markForCheck();\n    };\n    DataTableBodyRowComponent.prototype.calcStylesByGroup = function (group) {\n        var widths = this._columnGroupWidths;\n        var offsetX = this.offsetX;\n        var styles = {\n            width: widths[group] + \"px\"\n        };\n        if (group === 'left') {\n            translateXY(styles, offsetX, 0);\n        }\n        else if (group === 'right') {\n            var bodyWidth = parseInt(this.innerWidth + '', 0);\n            var totalDiff = widths.total - bodyWidth;\n            var offsetDiff = totalDiff - offsetX;\n            var offset = (offsetDiff + this.scrollbarHelper.width) * -1;\n            translateXY(styles, offset, 0);\n        }\n        return styles;\n    };\n    DataTableBodyRowComponent.prototype.onActivate = function (event, index) {\n        event.cellIndex = index;\n        event.rowElement = this._element;\n        this.activate.emit(event);\n    };\n    DataTableBodyRowComponent.prototype.onKeyDown = function (event) {\n        var keyCode = event.keyCode;\n        var isTargetRow = event.target === this._element;\n        var isAction = keyCode === Keys.return ||\n            keyCode === Keys.down ||\n            keyCode === Keys.up ||\n            keyCode === Keys.left ||\n            keyCode === Keys.right;\n        if (isAction && isTargetRow) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.activate.emit({\n                type: 'keydown',\n                event: event,\n                row: this.row,\n                rowElement: this._element\n            });\n        }\n    };\n    DataTableBodyRowComponent.prototype.onMouseenter = function (event) {\n        this.activate.emit({\n            type: 'mouseenter',\n            event: event,\n            row: this.row,\n            rowElement: this._element\n        });\n    };\n    DataTableBodyRowComponent.prototype.recalculateColumns = function (val) {\n        if (val === void 0) { val = this.columns; }\n        this._columns = val;\n        var colsByPin = columnsByPin(this._columns);\n        this._columnsByPin = columnsByPinArr(this._columns);\n        this._columnGroupWidths = columnGroupWidths(colsByPin, this._columns);\n    };\n    DataTableBodyRowComponent.prototype.onTreeAction = function () {\n        this.treeAction.emit();\n    };\n    DataTableBodyRowComponent.ctorParameters = function () { return [\n        { type: KeyValueDiffers },\n        { type: ScrollbarHelper, decorators: [{ type: SkipSelf }] },\n        { type: ChangeDetectorRef },\n        { type: ElementRef }\n    ]; };\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"columns\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"innerWidth\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"expanded\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"rowClass\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"row\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"group\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"isSelected\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"rowIndex\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"displayCheck\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"treeStatus\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"offsetX\", null);\n    __decorate([\n        HostBinding('class')\n    ], DataTableBodyRowComponent.prototype, \"cssClass\", null);\n    __decorate([\n        HostBinding('style.height.px'),\n        Input()\n    ], DataTableBodyRowComponent.prototype, \"rowHeight\", void 0);\n    __decorate([\n        HostBinding('style.width.px')\n    ], DataTableBodyRowComponent.prototype, \"columnsTotalWidths\", null);\n    __decorate([\n        Output()\n    ], DataTableBodyRowComponent.prototype, \"activate\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyRowComponent.prototype, \"treeAction\", void 0);\n    __decorate([\n        HostListener('keydown', ['$event'])\n    ], DataTableBodyRowComponent.prototype, \"onKeyDown\", null);\n    __decorate([\n        HostListener('mouseenter', ['$event'])\n    ], DataTableBodyRowComponent.prototype, \"onMouseenter\", null);\n    DataTableBodyRowComponent = __decorate([\n        Component({\n            selector: 'datatable-body-row',\n            changeDetection: ChangeDetectionStrategy.OnPush,\n            template: \"\\n    <div\\n      *ngFor=\\\"let colGroup of _columnsByPin; let i = index; trackBy: trackByGroups\\\"\\n      class=\\\"datatable-row-{{ colGroup.type }} datatable-row-group\\\"\\n      [ngStyle]=\\\"_groupStyles[colGroup.type]\\\"\\n    >\\n      <datatable-body-cell\\n        *ngFor=\\\"let column of colGroup.columns; let ii = index; trackBy: columnTrackingFn\\\"\\n        tabindex=\\\"-1\\\"\\n        [row]=\\\"row\\\"\\n        [group]=\\\"group\\\"\\n        [expanded]=\\\"expanded\\\"\\n        [isSelected]=\\\"isSelected\\\"\\n        [rowIndex]=\\\"rowIndex\\\"\\n        [column]=\\\"column\\\"\\n        [rowHeight]=\\\"rowHeight\\\"\\n        [displayCheck]=\\\"displayCheck\\\"\\n        [treeStatus]=\\\"treeStatus\\\"\\n        (activate)=\\\"onActivate($event, ii)\\\"\\n        (treeAction)=\\\"onTreeAction()\\\"\\n      >\\n      </datatable-body-cell>\\n    </div>\\n  \"\n        }),\n        __param(1, SkipSelf())\n    ], DataTableBodyRowComponent);\n    return DataTableBodyRowComponent;\n}());\n\nvar DataTableRowWrapperComponent = /** @class */ (function () {\n    function DataTableRowWrapperComponent(cd, differs) {\n        this.cd = cd;\n        this.differs = differs;\n        this.rowContextmenu = new EventEmitter(false);\n        this.groupContext = {\n            group: this.row,\n            expanded: this.expanded,\n            rowIndex: this.rowIndex\n        };\n        this.rowContext = {\n            row: this.row,\n            expanded: this.expanded,\n            rowIndex: this.rowIndex\n        };\n        this._expanded = false;\n        this.rowDiffer = differs.find({}).create();\n    }\n    Object.defineProperty(DataTableRowWrapperComponent.prototype, \"rowIndex\", {\n        get: function () {\n            return this._rowIndex;\n        },\n        set: function (val) {\n            this._rowIndex = val;\n            this.rowContext.rowIndex = val;\n            this.groupContext.rowIndex = val;\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableRowWrapperComponent.prototype, \"expanded\", {\n        get: function () {\n            return this._expanded;\n        },\n        set: function (val) {\n            this._expanded = val;\n            this.groupContext.expanded = val;\n            this.rowContext.expanded = val;\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTableRowWrapperComponent.prototype.ngDoCheck = function () {\n        if (this.rowDiffer.diff(this.row)) {\n            this.rowContext.row = this.row;\n            this.groupContext.group = this.row;\n            this.cd.markForCheck();\n        }\n    };\n    DataTableRowWrapperComponent.prototype.onContextmenu = function ($event) {\n        this.rowContextmenu.emit({ event: $event, row: this.row });\n    };\n    DataTableRowWrapperComponent.prototype.getGroupHeaderStyle = function () {\n        var styles = {};\n        styles['transform'] = 'translate3d(' + this.offsetX + 'px, 0px, 0px)';\n        styles['backface-visibility'] = 'hidden';\n        styles['width'] = this.innerWidth;\n        return styles;\n    };\n    DataTableRowWrapperComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef },\n        { type: KeyValueDiffers }\n    ]; };\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"innerWidth\", void 0);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"rowDetail\", void 0);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"groupHeader\", void 0);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"offsetX\", void 0);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"detailRowHeight\", void 0);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"row\", void 0);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"groupedRows\", void 0);\n    __decorate([\n        Output()\n    ], DataTableRowWrapperComponent.prototype, \"rowContextmenu\", void 0);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"rowIndex\", null);\n    __decorate([\n        Input()\n    ], DataTableRowWrapperComponent.prototype, \"expanded\", null);\n    __decorate([\n        HostListener('contextmenu', ['$event'])\n    ], DataTableRowWrapperComponent.prototype, \"onContextmenu\", null);\n    DataTableRowWrapperComponent = __decorate([\n        Component({\n            selector: 'datatable-row-wrapper',\n            changeDetection: ChangeDetectionStrategy.OnPush,\n            template: \"\\n    <div *ngIf=\\\"groupHeader && groupHeader.template\\\" class=\\\"datatable-group-header\\\" [ngStyle]=\\\"getGroupHeaderStyle()\\\">\\n      <ng-template\\n        *ngIf=\\\"groupHeader && groupHeader.template\\\"\\n        [ngTemplateOutlet]=\\\"groupHeader.template\\\"\\n        [ngTemplateOutletContext]=\\\"groupContext\\\"\\n      >\\n      </ng-template>\\n    </div>\\n    <ng-content *ngIf=\\\"(groupHeader && groupHeader.template && expanded) || !groupHeader || !groupHeader.template\\\">\\n    </ng-content>\\n    <div\\n      *ngIf=\\\"rowDetail && rowDetail.template && expanded\\\"\\n      [style.height.px]=\\\"detailRowHeight\\\"\\n      class=\\\"datatable-row-detail\\\"\\n    >\\n      <ng-template\\n        *ngIf=\\\"rowDetail && rowDetail.template\\\"\\n        [ngTemplateOutlet]=\\\"rowDetail.template\\\"\\n        [ngTemplateOutletContext]=\\\"rowContext\\\"\\n      >\\n      </ng-template>\\n    </div>\\n  \",\n            host: {\n                class: 'datatable-row-wrapper'\n            }\n        })\n    ], DataTableRowWrapperComponent);\n    return DataTableRowWrapperComponent;\n}());\n\nvar DataTableBodyCellComponent = /** @class */ (function () {\n    function DataTableBodyCellComponent(element, cd) {\n        this.cd = cd;\n        this.activate = new EventEmitter();\n        this.treeAction = new EventEmitter();\n        this.isFocused = false;\n        this.onCheckboxChangeFn = this.onCheckboxChange.bind(this);\n        this.activateFn = this.activate.emit.bind(this.activate);\n        this.cellContext = {\n            onCheckboxChangeFn: this.onCheckboxChangeFn,\n            activateFn: this.activateFn,\n            row: this.row,\n            group: this.group,\n            value: this.value,\n            column: this.column,\n            rowHeight: this.rowHeight,\n            isSelected: this.isSelected,\n            rowIndex: this.rowIndex,\n            treeStatus: this.treeStatus,\n            onTreeAction: this.onTreeAction.bind(this)\n        };\n        this._element = element.nativeElement;\n    }\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"group\", {\n        get: function () {\n            return this._group;\n        },\n        set: function (group) {\n            this._group = group;\n            this.cellContext.group = group;\n            this.checkValueUpdates();\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"rowHeight\", {\n        get: function () {\n            return this._rowHeight;\n        },\n        set: function (val) {\n            this._rowHeight = val;\n            this.cellContext.rowHeight = val;\n            this.checkValueUpdates();\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"isSelected\", {\n        get: function () {\n            return this._isSelected;\n        },\n        set: function (val) {\n            this._isSelected = val;\n            this.cellContext.isSelected = val;\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"expanded\", {\n        get: function () {\n            return this._expanded;\n        },\n        set: function (val) {\n            this._expanded = val;\n            this.cellContext.expanded = val;\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"rowIndex\", {\n        get: function () {\n            return this._rowIndex;\n        },\n        set: function (val) {\n            this._rowIndex = val;\n            this.cellContext.rowIndex = val;\n            this.checkValueUpdates();\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"column\", {\n        get: function () {\n            return this._column;\n        },\n        set: function (column) {\n            this._column = column;\n            this.cellContext.column = column;\n            this.checkValueUpdates();\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"row\", {\n        get: function () {\n            return this._row;\n        },\n        set: function (row) {\n            this._row = row;\n            this.cellContext.row = row;\n            this.checkValueUpdates();\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"sorts\", {\n        get: function () {\n            return this._sorts;\n        },\n        set: function (val) {\n            this._sorts = val;\n            this.calcSortDir = this.calcSortDir(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"treeStatus\", {\n        get: function () {\n            return this._treeStatus;\n        },\n        set: function (status) {\n            if (status !== 'collapsed' && status !== 'expanded' && status !== 'loading' && status !== 'disabled') {\n                this._treeStatus = 'collapsed';\n            }\n            else {\n                this._treeStatus = status;\n            }\n            this.cellContext.treeStatus = this._treeStatus;\n            this.checkValueUpdates();\n            this.cd.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"columnCssClasses\", {\n        get: function () {\n            var e_1, _a;\n            var cls = 'datatable-body-cell';\n            if (this.column.cellClass) {\n                if (typeof this.column.cellClass === 'string') {\n                    cls += ' ' + this.column.cellClass;\n                }\n                else if (typeof this.column.cellClass === 'function') {\n                    var res = this.column.cellClass({\n                        row: this.row,\n                        group: this.group,\n                        column: this.column,\n                        value: this.value,\n                        rowHeight: this.rowHeight\n                    });\n                    if (typeof res === 'string') {\n                        cls += ' ' + res;\n                    }\n                    else if (typeof res === 'object') {\n                        var keys = Object.keys(res);\n                        try {\n                            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n                                var k = keys_1_1.value;\n                                if (res[k] === true) {\n                                    cls += \" \" + k;\n                                }\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                    }\n                }\n            }\n            if (!this.sortDir) {\n                cls += ' sort-active';\n            }\n            if (this.isFocused) {\n                cls += ' active';\n            }\n            if (this.sortDir === SortDirection.asc) {\n                cls += ' sort-asc';\n            }\n            if (this.sortDir === SortDirection.desc) {\n                cls += ' sort-desc';\n            }\n            return cls;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"width\", {\n        get: function () {\n            return this.column.width;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"minWidth\", {\n        get: function () {\n            return this.column.minWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"maxWidth\", {\n        get: function () {\n            return this.column.maxWidth;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyCellComponent.prototype, \"height\", {\n        get: function () {\n            var height = this.rowHeight;\n            if (isNaN(height)) {\n                return height;\n            }\n            return height + 'px';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DataTableBodyCellComponent.prototype.ngDoCheck = function () {\n        this.checkValueUpdates();\n    };\n    DataTableBodyCellComponent.prototype.ngOnDestroy = function () {\n        if (this.cellTemplate) {\n            this.cellTemplate.clear();\n        }\n    };\n    DataTableBodyCellComponent.prototype.checkValueUpdates = function () {\n        var value = '';\n        if (!this.row || !this.column) {\n            value = '';\n        }\n        else {\n            var val = this.column.$$valueGetter(this.row, this.column.prop);\n            var userPipe = this.column.pipe;\n            if (userPipe) {\n                value = userPipe.transform(val);\n            }\n            else if (value !== undefined) {\n                value = val;\n            }\n        }\n        if (this.value !== value) {\n            this.value = value;\n            this.cellContext.value = value;\n            this.sanitizedValue = value !== null && value !== undefined ? this.stripHtml(value) : value;\n            this.cd.markForCheck();\n        }\n    };\n    DataTableBodyCellComponent.prototype.onFocus = function () {\n        this.isFocused = true;\n    };\n    DataTableBodyCellComponent.prototype.onBlur = function () {\n        this.isFocused = false;\n    };\n    DataTableBodyCellComponent.prototype.onClick = function (event) {\n        this.activate.emit({\n            type: 'click',\n            event: event,\n            row: this.row,\n            group: this.group,\n            rowHeight: this.rowHeight,\n            column: this.column,\n            value: this.value,\n            cellElement: this._element\n        });\n    };\n    DataTableBodyCellComponent.prototype.onDblClick = function (event) {\n        this.activate.emit({\n            type: 'dblclick',\n            event: event,\n            row: this.row,\n            group: this.group,\n            rowHeight: this.rowHeight,\n            column: this.column,\n            value: this.value,\n            cellElement: this._element\n        });\n    };\n    DataTableBodyCellComponent.prototype.onKeyDown = function (event) {\n        var keyCode = event.keyCode;\n        var isTargetCell = event.target === this._element;\n        var isAction = keyCode === Keys.return ||\n            keyCode === Keys.down ||\n            keyCode === Keys.up ||\n            keyCode === Keys.left ||\n            keyCode === Keys.right;\n        if (isAction && isTargetCell) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.activate.emit({\n                type: 'keydown',\n                event: event,\n                row: this.row,\n                group: this.group,\n                rowHeight: this.rowHeight,\n                column: this.column,\n                value: this.value,\n                cellElement: this._element\n            });\n        }\n    };\n    DataTableBodyCellComponent.prototype.onCheckboxChange = function (event) {\n        this.activate.emit({\n            type: 'checkbox',\n            event: event,\n            row: this.row,\n            group: this.group,\n            rowHeight: this.rowHeight,\n            column: this.column,\n            value: this.value,\n            cellElement: this._element,\n            treeStatus: 'collapsed'\n        });\n    };\n    DataTableBodyCellComponent.prototype.calcSortDir = function (sorts) {\n        var _this = this;\n        if (!sorts) {\n            return;\n        }\n        var sort = sorts.find(function (s) {\n            return s.prop === _this.column.prop;\n        });\n        if (sort) {\n            return sort.dir;\n        }\n    };\n    DataTableBodyCellComponent.prototype.stripHtml = function (html) {\n        if (!html.replace) {\n            return html;\n        }\n        return html.replace(/<\\/?[^>]+(>|$)/g, '');\n    };\n    DataTableBodyCellComponent.prototype.onTreeAction = function () {\n        this.treeAction.emit(this.row);\n    };\n    DataTableBodyCellComponent.prototype.calcLeftMargin = function (column, row) {\n        var levelIndent = column.treeLevelIndent != null ? column.treeLevelIndent : 50;\n        return column.isTreeColumn ? row.level * levelIndent : 0;\n    };\n    DataTableBodyCellComponent.ctorParameters = function () { return [\n        { type: ElementRef },\n        { type: ChangeDetectorRef }\n    ]; };\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"displayCheck\", void 0);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"group\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"rowHeight\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"isSelected\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"expanded\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"rowIndex\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"column\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"row\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"sorts\", null);\n    __decorate([\n        Input()\n    ], DataTableBodyCellComponent.prototype, \"treeStatus\", null);\n    __decorate([\n        Output()\n    ], DataTableBodyCellComponent.prototype, \"activate\", void 0);\n    __decorate([\n        Output()\n    ], DataTableBodyCellComponent.prototype, \"treeAction\", void 0);\n    __decorate([\n        ViewChild('cellTemplate', { read: ViewContainerRef, static: true })\n    ], DataTableBodyCellComponent.prototype, \"cellTemplate\", void 0);\n    __decorate([\n        HostBinding('class')\n    ], DataTableBodyCellComponent.prototype, \"columnCssClasses\", null);\n    __decorate([\n        HostBinding('style.width.px')\n    ], DataTableBodyCellComponent.prototype, \"width\", null);\n    __decorate([\n        HostBinding('style.minWidth.px')\n    ], DataTableBodyCellComponent.prototype, \"minWidth\", null);\n    __decorate([\n        HostBinding('style.maxWidth.px')\n    ], DataTableBodyCellComponent.prototype, \"maxWidth\", null);\n    __decorate([\n        HostBinding('style.height')\n    ], DataTableBodyCellComponent.prototype, \"height\", null);\n    __decorate([\n        HostListener('focus')\n    ], DataTableBodyCellComponent.prototype, \"onFocus\", null);\n    __decorate([\n        HostListener('blur')\n    ], DataTableBodyCellComponent.prototype, \"onBlur\", null);\n    __decorate([\n        HostListener('click', ['$event'])\n    ], DataTableBodyCellComponent.prototype, \"onClick\", null);\n    __decorate([\n        HostListener('dblclick', ['$event'])\n    ], DataTableBodyCellComponent.prototype, \"onDblClick\", null);\n    __decorate([\n        HostListener('keydown', ['$event'])\n    ], DataTableBodyCellComponent.prototype, \"onKeyDown\", null);\n    DataTableBodyCellComponent = __decorate([\n        Component({\n            selector: 'datatable-body-cell',\n            changeDetection: ChangeDetectionStrategy.OnPush,\n            template: \"\\n    <div class=\\\"datatable-body-cell-label\\\" [style.margin-left.px]=\\\"calcLeftMargin(column, row)\\\">\\n      <label\\n        *ngIf=\\\"column.checkboxable && (!displayCheck || displayCheck(row, column, value))\\\"\\n        class=\\\"datatable-checkbox\\\"\\n      >\\n        <input type=\\\"checkbox\\\" [checked]=\\\"isSelected\\\" (click)=\\\"onCheckboxChange($event)\\\" />\\n      </label>\\n      <ng-container *ngIf=\\\"column.isTreeColumn\\\">\\n        <button\\n          *ngIf=\\\"!column.treeToggleTemplate\\\"\\n          class=\\\"datatable-tree-button\\\"\\n          [disabled]=\\\"treeStatus === 'disabled'\\\"\\n          (click)=\\\"onTreeAction()\\\"\\n        >\\n          <span>\\n            <i *ngIf=\\\"treeStatus === 'loading'\\\" class=\\\"icon datatable-icon-collapse\\\"></i>\\n            <i *ngIf=\\\"treeStatus === 'collapsed'\\\" class=\\\"icon datatable-icon-up\\\"></i>\\n            <i *ngIf=\\\"treeStatus === 'expanded' || treeStatus === 'disabled'\\\" class=\\\"icon datatable-icon-down\\\"></i>\\n          </span>\\n        </button>\\n        <ng-template\\n          *ngIf=\\\"column.treeToggleTemplate\\\"\\n          [ngTemplateOutlet]=\\\"column.treeToggleTemplate\\\"\\n          [ngTemplateOutletContext]=\\\"{ cellContext: cellContext }\\\"\\n        >\\n        </ng-template>\\n      </ng-container>\\n\\n      <span *ngIf=\\\"!column.cellTemplate\\\" [title]=\\\"sanitizedValue\\\" [innerHTML]=\\\"value\\\"> </span>\\n      <ng-template\\n        #cellTemplate\\n        *ngIf=\\\"column.cellTemplate\\\"\\n        [ngTemplateOutlet]=\\\"column.cellTemplate\\\"\\n        [ngTemplateOutletContext]=\\\"cellContext\\\"\\n      >\\n      </ng-template>\\n    </div>\\n  \"\n        })\n    ], DataTableBodyCellComponent);\n    return DataTableBodyCellComponent;\n}());\n\nfunction selectRows(selected, row, comparefn) {\n    var selectedIndex = comparefn(row, selected);\n    if (selectedIndex > -1) {\n        selected.splice(selectedIndex, 1);\n    }\n    else {\n        selected.push(row);\n    }\n    return selected;\n}\nfunction selectRowsBetween(selected, rows, index, prevIndex, comparefn) {\n    var reverse = index < prevIndex;\n    for (var i = 0; i < rows.length; i++) {\n        var row = rows[i];\n        var greater = i >= prevIndex && i <= index;\n        var lesser = i <= prevIndex && i >= index;\n        var range = { start: 0, end: 0 };\n        if (reverse) {\n            range = {\n                start: index,\n                end: prevIndex\n            };\n        }\n        else {\n            range = {\n                start: prevIndex,\n                end: index + 1\n            };\n        }\n        if ((reverse && lesser) || (!reverse && greater)) {\n            // if in the positive range to be added to `selected`, and\n            // not already in the selected array, add it\n            if (i >= range.start && i <= range.end) {\n                selected.push(row);\n            }\n        }\n    }\n    return selected;\n}\n\nvar DataTableSelectionComponent = /** @class */ (function () {\n    function DataTableSelectionComponent() {\n        this.activate = new EventEmitter();\n        this.select = new EventEmitter();\n    }\n    DataTableSelectionComponent.prototype.selectRow = function (event, index, row) {\n        var _a;\n        if (!this.selectEnabled)\n            return;\n        var chkbox = this.selectionType === SelectionType.checkbox;\n        var multi = this.selectionType === SelectionType.multi;\n        var multiClick = this.selectionType === SelectionType.multiClick;\n        var selected = [];\n        if (multi || chkbox || multiClick) {\n            if (event.shiftKey) {\n                selected = selectRowsBetween([], this.rows, index, this.prevIndex, this.getRowSelectedIdx.bind(this));\n            }\n            else if (event.ctrlKey || event.metaKey || multiClick || chkbox) {\n                selected = selectRows(__spread(this.selected), row, this.getRowSelectedIdx.bind(this));\n            }\n            else {\n                selected = selectRows([], row, this.getRowSelectedIdx.bind(this));\n            }\n        }\n        else {\n            selected = selectRows([], row, this.getRowSelectedIdx.bind(this));\n        }\n        if (typeof this.selectCheck === 'function') {\n            selected = selected.filter(this.selectCheck.bind(this));\n        }\n        this.selected.splice(0, this.selected.length);\n        (_a = this.selected).push.apply(_a, __spread(selected));\n        this.prevIndex = index;\n        this.select.emit({\n            selected: selected\n        });\n    };\n    DataTableSelectionComponent.prototype.onActivate = function (model, index) {\n        var type = model.type, event = model.event, row = model.row;\n        var chkbox = this.selectionType === SelectionType.checkbox;\n        var select = (!chkbox && (type === 'click' || type === 'dblclick')) || (chkbox && type === 'checkbox');\n        if (select) {\n            this.selectRow(event, index, row);\n        }\n        else if (type === 'keydown') {\n            if (event.keyCode === Keys.return) {\n                this.selectRow(event, index, row);\n            }\n            else {\n                this.onKeyboardFocus(model);\n            }\n        }\n        this.activate.emit(model);\n    };\n    DataTableSelectionComponent.prototype.onKeyboardFocus = function (model) {\n        var keyCode = model.event.keyCode;\n        var shouldFocus = keyCode === Keys.up || keyCode === Keys.down || keyCode === Keys.right || keyCode === Keys.left;\n        if (shouldFocus) {\n            var isCellSelection = this.selectionType === SelectionType.cell;\n            if (!model.cellElement || !isCellSelection) {\n                this.focusRow(model.rowElement, keyCode);\n            }\n            else if (isCellSelection) {\n                this.focusCell(model.cellElement, model.rowElement, keyCode, model.cellIndex);\n            }\n        }\n    };\n    DataTableSelectionComponent.prototype.focusRow = function (rowElement, keyCode) {\n        var nextRowElement = this.getPrevNextRow(rowElement, keyCode);\n        if (nextRowElement)\n            nextRowElement.focus();\n    };\n    DataTableSelectionComponent.prototype.getPrevNextRow = function (rowElement, keyCode) {\n        var parentElement = rowElement.parentElement;\n        if (parentElement) {\n            var focusElement = void 0;\n            if (keyCode === Keys.up) {\n                focusElement = parentElement.previousElementSibling;\n            }\n            else if (keyCode === Keys.down) {\n                focusElement = parentElement.nextElementSibling;\n            }\n            if (focusElement && focusElement.children.length) {\n                return focusElement.children[0];\n            }\n        }\n    };\n    DataTableSelectionComponent.prototype.focusCell = function (cellElement, rowElement, keyCode, cellIndex) {\n        var nextCellElement;\n        if (keyCode === Keys.left) {\n            nextCellElement = cellElement.previousElementSibling;\n        }\n        else if (keyCode === Keys.right) {\n            nextCellElement = cellElement.nextElementSibling;\n        }\n        else if (keyCode === Keys.up || keyCode === Keys.down) {\n            var nextRowElement = this.getPrevNextRow(rowElement, keyCode);\n            if (nextRowElement) {\n                var children = nextRowElement.getElementsByClassName('datatable-body-cell');\n                if (children.length)\n                    nextCellElement = children[cellIndex];\n            }\n        }\n        if (nextCellElement)\n            nextCellElement.focus();\n    };\n    DataTableSelectionComponent.prototype.getRowSelected = function (row) {\n        return this.getRowSelectedIdx(row, this.selected) > -1;\n    };\n    DataTableSelectionComponent.prototype.getRowSelectedIdx = function (row, selected) {\n        var _this = this;\n        if (!selected || !selected.length)\n            return -1;\n        var rowId = this.rowIdentity(row);\n        return selected.findIndex(function (r) {\n            var id = _this.rowIdentity(r);\n            return id === rowId;\n        });\n    };\n    __decorate([\n        Input()\n    ], DataTableSelectionComponent.prototype, \"rows\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSelectionComponent.prototype, \"selected\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSelectionComponent.prototype, \"selectEnabled\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSelectionComponent.prototype, \"selectionType\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSelectionComponent.prototype, \"rowIdentity\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSelectionComponent.prototype, \"selectCheck\", void 0);\n    __decorate([\n        Output()\n    ], DataTableSelectionComponent.prototype, \"activate\", void 0);\n    __decorate([\n        Output()\n    ], DataTableSelectionComponent.prototype, \"select\", void 0);\n    DataTableSelectionComponent = __decorate([\n        Component({\n            selector: 'datatable-selection',\n            template: \" <ng-content></ng-content> \",\n            changeDetection: ChangeDetectionStrategy.OnPush\n        })\n    ], DataTableSelectionComponent);\n    return DataTableSelectionComponent;\n}());\n\nfunction defaultSumFunc(cells) {\n    var cellsWithValues = cells.filter(function (cell) { return !!cell; });\n    if (!cellsWithValues.length) {\n        return null;\n    }\n    if (cellsWithValues.some(function (cell) { return typeof cell !== 'number'; })) {\n        return null;\n    }\n    return cellsWithValues.reduce(function (res, cell) { return res + cell; });\n}\nfunction noopSumFunc(cells) {\n    return null;\n}\nvar DataTableSummaryRowComponent = /** @class */ (function () {\n    function DataTableSummaryRowComponent() {\n        this.summaryRow = {};\n    }\n    DataTableSummaryRowComponent.prototype.ngOnChanges = function () {\n        if (!this.columns || !this.rows) {\n            return;\n        }\n        this.updateInternalColumns();\n        this.updateValues();\n    };\n    DataTableSummaryRowComponent.prototype.updateInternalColumns = function () {\n        this._internalColumns = this.columns.map(function (col) { return (__assign(__assign({}, col), { cellTemplate: col.summaryTemplate })); });\n    };\n    DataTableSummaryRowComponent.prototype.updateValues = function () {\n        var _this = this;\n        this.summaryRow = {};\n        this.columns\n            .filter(function (col) { return !col.summaryTemplate; })\n            .forEach(function (col) {\n            var cellsFromSingleColumn = _this.rows.map(function (row) { return row[col.prop]; });\n            var sumFunc = _this.getSummaryFunction(col);\n            _this.summaryRow[col.prop] = col.pipe\n                ? col.pipe.transform(sumFunc(cellsFromSingleColumn))\n                : sumFunc(cellsFromSingleColumn);\n        });\n    };\n    DataTableSummaryRowComponent.prototype.getSummaryFunction = function (column) {\n        if (column.summaryFunc === undefined) {\n            return defaultSumFunc;\n        }\n        else if (column.summaryFunc === null) {\n            return noopSumFunc;\n        }\n        else {\n            return column.summaryFunc;\n        }\n    };\n    __decorate([\n        Input()\n    ], DataTableSummaryRowComponent.prototype, \"rows\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSummaryRowComponent.prototype, \"columns\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSummaryRowComponent.prototype, \"rowHeight\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSummaryRowComponent.prototype, \"offsetX\", void 0);\n    __decorate([\n        Input()\n    ], DataTableSummaryRowComponent.prototype, \"innerWidth\", void 0);\n    DataTableSummaryRowComponent = __decorate([\n        Component({\n            selector: 'datatable-summary-row',\n            template: \"\\n    <datatable-body-row\\n      *ngIf=\\\"summaryRow && _internalColumns\\\"\\n      tabindex=\\\"-1\\\"\\n      [innerWidth]=\\\"innerWidth\\\"\\n      [offsetX]=\\\"offsetX\\\"\\n      [columns]=\\\"_internalColumns\\\"\\n      [rowHeight]=\\\"rowHeight\\\"\\n      [row]=\\\"summaryRow\\\"\\n      [rowIndex]=\\\"-1\\\"\\n    >\\n    </datatable-body-row>\\n  \",\n            host: {\n                class: 'datatable-summary-row'\n            }\n        })\n    ], DataTableSummaryRowComponent);\n    return DataTableSummaryRowComponent;\n}());\n\nvar NgxDatatableModule = /** @class */ (function () {\n    function NgxDatatableModule() {\n    }\n    NgxDatatableModule_1 = NgxDatatableModule;\n    /**\n     * Configure global configuration via INgxDatatableConfig\n     * @param configuration\n     */\n    NgxDatatableModule.forRoot = function (configuration) {\n        return {\n            ngModule: NgxDatatableModule_1,\n            providers: [{ provide: 'configuration', useValue: configuration }]\n        };\n    };\n    var NgxDatatableModule_1;\n    NgxDatatableModule = NgxDatatableModule_1 = __decorate([\n        NgModule({\n            imports: [CommonModule],\n            providers: [ScrollbarHelper, DimensionsHelper, ColumnChangesService],\n            declarations: [\n                DataTableFooterTemplateDirective,\n                VisibilityDirective,\n                DraggableDirective,\n                ResizeableDirective,\n                OrderableDirective,\n                LongPressDirective,\n                ScrollerComponent,\n                DatatableComponent,\n                DataTableColumnDirective,\n                DataTableHeaderComponent,\n                DataTableHeaderCellComponent,\n                DataTableBodyComponent,\n                DataTableFooterComponent,\n                DataTablePagerComponent,\n                ProgressBarComponent,\n                DataTableBodyRowComponent,\n                DataTableRowWrapperComponent,\n                DatatableRowDetailDirective,\n                DatatableGroupHeaderDirective,\n                DatatableRowDetailTemplateDirective,\n                DataTableBodyCellComponent,\n                DataTableSelectionComponent,\n                DataTableColumnHeaderDirective,\n                DataTableColumnCellDirective,\n                DataTableColumnCellTreeToggle,\n                DatatableFooterDirective,\n                DatatableGroupHeaderTemplateDirective,\n                DataTableSummaryRowComponent\n            ],\n            exports: [\n                DatatableComponent,\n                DatatableRowDetailDirective,\n                DatatableGroupHeaderDirective,\n                DatatableRowDetailTemplateDirective,\n                DataTableColumnDirective,\n                DataTableColumnHeaderDirective,\n                DataTableColumnCellDirective,\n                DataTableColumnCellTreeToggle,\n                DataTableFooterTemplateDirective,\n                DatatableFooterDirective,\n                DataTablePagerComponent,\n                DatatableGroupHeaderTemplateDirective\n            ]\n        })\n    ], NgxDatatableModule);\n    return NgxDatatableModule;\n}());\n\nvar ClickType;\n(function (ClickType) {\n    ClickType[\"single\"] = \"single\";\n    ClickType[\"double\"] = \"double\";\n})(ClickType || (ClickType = {}));\n\nif (typeof document !== 'undefined' && !document.elementsFromPoint) {\n    document.elementsFromPoint = elementsFromPoint;\n}\n/*tslint:disable*/\n/**\n * Polyfill for `elementsFromPoint`\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint\n * https://gist.github.com/iddan/54d5d9e58311b0495a91bf06de661380\n * https://gist.github.com/oslego/7265412\n */\nfunction elementsFromPoint(x, y) {\n    var elements = [];\n    var previousPointerEvents = [];\n    var current; // TODO: window.getComputedStyle should be used with inferred type (Element)\n    var i;\n    var d;\n    //if (document === undefined) return elements;\n    // get all elements via elementFromPoint, and remove them from hit-testing in order\n    while ((current = document.elementFromPoint(x, y)) && elements.indexOf(current) === -1 && current != null) {\n        // push the element and its current style\n        elements.push(current);\n        previousPointerEvents.push({\n            value: current.style.getPropertyValue('pointer-events'),\n            priority: current.style.getPropertyPriority('pointer-events')\n        });\n        // add \"pointer-events: none\", to get to the underlying element\n        current.style.setProperty('pointer-events', 'none', 'important');\n    }\n    // restore the previous pointer-events values\n    for (i = previousPointerEvents.length; (d = previousPointerEvents[--i]);) {\n        elements[i].style.setProperty('pointer-events', d.value ? d.value : '', d.priority);\n    }\n    // return our results\n    return elements;\n}\n/*tslint:enable*/\n\n/*\n * Public API Surface of ngx-datatable\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ClickType, ColumnChangesService, ColumnMode, ContextmenuType, DataTableBodyCellComponent, DataTableBodyComponent, DataTableBodyRowComponent, DataTableColumnCellDirective, DataTableColumnCellTreeToggle, DataTableColumnDirective, DataTableColumnHeaderDirective, DataTableFooterComponent, DataTableFooterTemplateDirective, DataTableHeaderCellComponent, DataTableHeaderComponent, DataTablePagerComponent, DataTableRowWrapperComponent, DataTableSelectionComponent, DataTableSummaryRowComponent, DatatableComponent, DatatableFooterDirective, DatatableGroupHeaderDirective, DatatableGroupHeaderTemplateDirective, DatatableRowDetailDirective, DatatableRowDetailTemplateDirective, DimensionsHelper, DraggableDirective, Keys, LongPressDirective, NgxDatatableModule, OrderableDirective, ProgressBarComponent, ResizeableDirective, RowHeightCache, ScrollbarHelper, ScrollerComponent, SelectionType, SortDirection, SortType, VisibilityDirective, adjustColumnWidths, camelCase, columnGroupWidths, columnTotalWidth, columnsByPin, columnsByPinArr, columnsTotalWidth, deCamelCase, deepValueGetter, elementsFromPoint, emptyStringGetter, forceFillColumnWidths, getTotalFlexGrow, getVendorPrefixedName, getterForProp, groupRowsByParents, id, isNullOrUndefined, nextSortDir, numericIndexGetter, optionalGetterForProp, orderByComparator, selectRows, selectRowsBetween, setColumnDefaults, shallowValueGetter, sortRows, throttle, throttleable, translateTemplates, translateXY, ɵ0 };\n"]}